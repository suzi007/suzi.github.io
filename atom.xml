<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏子部落阁</title>
  
  
  <link href="http://suzi007.github.io/atom.xml" rel="self"/>
  
  <link href="http://suzi007.github.io/"/>
  <updated>2024-04-17T07:28:02.811Z</updated>
  <id>http://suzi007.github.io/</id>
  
  <author>
    <name>苏子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KaliTool</title>
    <link href="http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/KaliTool/"/>
    <id>http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/KaliTool/</id>
    <published>2024-04-17T07:26:29.000Z</published>
    <updated>2024-04-17T07:28:02.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1 信息收集"></a>1 信息收集</h1><h2 id="1-1-Amap"><a href="#1-1-Amap" class="headerlink" title="1.1 Amap"></a>1.1 Amap</h2><p>   Amap是一个服务扫描工具，它是最早被称为下一代扫描器的软件，可以识别不同的应用程序，即使这些程序运行在一个异常的端口上。Amap最早开始支持UDP协议和IPv6地址空间的扫描，可作为nmap重要的补充工具。同时amap还提供未知应用特征的自动测定功能，让我们可以方便定制扫描结果</p><h2 id="1-2-Arp-scan"><a href="#1-2-Arp-scan" class="headerlink" title="1.2 Arp-scan"></a>1.2 Arp-scan</h2><p>   Arp-scan是一个用来进行系统发现和指纹识别的命令行工具，它可以构建并发送ARP请求到指定的IP地址，并且显示返回的任何响应</p><h2 id="1-3-DMitry"><a href="#1-3-DMitry" class="headerlink" title="1.3 DMitry"></a>1.3 DMitry</h2><p>   DMitry是一个用C语言开发的UNIX&#x2F;（GUN）Linux命令行工具，能够收集目标主机尽可能多的信息，包括主机所在的子域、电子邮件地址、运行时间、TCP端口扫描、whois查询等。</p><h2 id="1-4-Dnmap"><a href="#1-4-Dnmap" class="headerlink" title="1.4   Dnmap"></a>1.4   Dnmap</h2><p>   Dnmap是一个能够在多台客户机上执行分布式nmap扫描的框架，它可以读取包括nmap命令的文件，并把该命令文件发给与之相连的多台客户机，在这些客户机上执行nmap文件中的命令。dnmap框架采用的是客户机&#x2F;服务器模式，服务器发布命令，客户机执行命令，从而实现分布式nmap扫描</p><h2 id="1-5-Dnsenum"><a href="#1-5-Dnsenum" class="headerlink" title="1.5 Dnsenum"></a>1.5 Dnsenum</h2><p>   Dnsenum通过执行多线程Perl脚本来枚举域的DNS信息，从而发现非相邻的IP块</p><h2 id="1-6-Fierce"><a href="#1-6-Fierce" class="headerlink" title="1.6 Fierce"></a>1.6 Fierce</h2><p>   Fierce不是一个IP地址扫描器，也不是一个DDos工具，它不是涉及来扫描整个互联网或执行任何非针对性的攻击的。它是一个Perl脚本，是一个侦察工具，可以对域进行快速扫描，用来定位公司网络内部和外部可能的目标</p><h2 id="1-7-Maltego"><a href="#1-7-Maltego" class="headerlink" title="1.7 Maltego"></a>1.7 Maltego</h2><p>   Maltego是一个独特的平台，用于向组织拥有和运营的环境传递清晰的威胁画面。Maltego的独特优势在于证明单点故障的复杂性和严重性以及网络设备间的信任问题</p><h2 id="1-8-Nmap"><a href="#1-8-Nmap" class="headerlink" title="1.8   Nmap"></a>1.8   Nmap</h2><p>   Nmap是一个免费的、开源的用于网络发现和安全审计的工具，可用于网络资产管理、网络服务升级管理、监控主机或服务正常运行等任务Nmap功能强大，可判断主机是否在线，判断主机运行的操作系统类型和版本，判断主机提供了哪些服务（应用程序名称和版本）、使用了什么类型的过滤器或防火墙，以及其他几十种特性。</p><h2 id="1-9-P-0-f"><a href="#1-9-P-0-f" class="headerlink" title="1.9 P 0 f"></a>1.9 P 0 f</h2><p>   P0f来对主机上的操作系统进行鉴别，即使是在系统上装有性能良好的防火墙的 p0f是一款被动探测工具,能够通过捕获并分析目标主机发出的数据包 NAT、负载均衡、应用代理等,它是一个万能的被动操作系统指纹工具。情况下也没有问题。同时p0f在网络分析方面功能强大,可以用它来分析</p><h2 id="1-10-Recon-NG"><a href="#1-10-Recon-NG" class="headerlink" title="1.10 Recon-NG"></a>1.10 Recon-NG</h2><p>   Recon-NG是由Python编写的一个开源的Web侦查(信息收集)框架, 成数据库，可把查询结果结构化存储在其中，有报告模块，把结果导出为报告。使用它可以自动地收集信息和网络侦查。其命令格式与Metasploit默认集</p><h2 id="1-11-Smtp-user-enum"><a href="#1-11-Smtp-user-enum" class="headerlink" title="1.11 Smtp-user-enum"></a>1.11 Smtp-user-enum</h2><p>   Smtp-user-enum大部分基于类Unix系统的邮件服务,采用操作系统账号作为邮件账号, 因此对于其邮件账号的探测，其实就等同于对操作系统账号的探测，以便进 行后续弱密码口令的破解。smtp-user-enum基于三种方法验证邮件账号是否 存在，同时支持基于字典的批量验证。</p><h2 id="1-12-Snmp-check"><a href="#1-12-Snmp-check" class="headerlink" title="1.12 Snmp-check"></a>1.12 Snmp-check</h2><p>   Snmp-check是一款基于默认或指定团体名,对目标设备进行信息批量查 询的工具,其默认支持Windows、类Unix、网络设备和打印机等。完全依靠 人工来监控大型网络的运行状态,是一种令人崩溃的任务。SNMP协议可以大 大简化系统和网络管理员的工作，实现问题的快速定位和排查。</p><h2 id="1-13-Unicornscan"><a href="#1-13-Unicornscan" class="headerlink" title="1.13 Unicornscan"></a>1.13 Unicornscan</h2><p>   Unicornscan是一款通过尝试连接用户系统(User-Land)分布式TCP&#x2F; IP堆栈获得信息和关联关系的端口扫描器。它是一个新的信息收集引擎,主 要用于安全研究和通讯测试，主要特点是精确、灵活而且高效。</p><h2 id="1-14-Wireshark"><a href="#1-14-Wireshark" class="headerlink" title="1.14 Wireshark"></a>1.14 Wireshark</h2><p>   Wireshark从Ethereal发展而来,是一款网络数据包捕获和分析工具, 它使用WinPcap作为接口,可跳过TCP&#x2F;IP协议栈直接与网卡进行数据包的 交换。</p><h1 id="2-二、脆弱性分析"><a href="#2-二、脆弱性分析" class="headerlink" title="2 二、脆弱性分析"></a>2 二、脆弱性分析</h1><h2 id="2-1-BQSQL"><a href="#2-1-BQSQL" class="headerlink" title="2.1 BQSQL"></a>2.1 BQSQL</h2><p>   BQSQL是一款用Python写的SQL盲注框架,对SQL注入漏洞 攻击非常有效。它是一种半自动工具,自带一个直观的UI用户界 面,允许许多难以触发的SQL注入变得用户化,使设置攻击更容易。BBQSQL用法非常灵活,与数据库无关,不关心数据或数据库,而大 多数SQL注入工具是要具体的数据库或语言建立的。</p><h2 id="2-2-BED"><a href="#2-2-BED" class="headerlink" title="2.2  BED"></a>2.2  BED</h2><p>   BED(Bruteforce Exploit Detector)是一款缓存区漏洞检测 工具。它预置了十一种插件。这些插件针对不同的服务或系统，如 FTP、SMTP、POP等。同时,这些插件内包含了已知的各种攻击载荷。BED通过加载插件,向目标主机发送攻击数据。如果发现目标无法响 应，说明目标可能存在溢出区漏洞。经过多次测试验证，就可以判断 漏洞出现的位置。然后手工执行验证，采用代码审核、反编译等方式， 就可以找出漏洞具体触发机制，从而加以利用</p><h2 id="2-3-Cisco-auditing-tool"><a href="#2-3-Cisco-auditing-tool" class="headerlink" title="2.3 Cisco-auditing-tool"></a>2.3 Cisco-auditing-tool</h2><p>   Cisco-auditing-tool简称CAT,是一款小型的安全审计工具, 可检测出Cisco路由器常见的漏洞,可发现注入默认密码、默认 SNMP字符串和老版本IOS上存在的漏洞。</p><h2 id="2-4-Cisco-global-exploiter"><a href="#2-4-Cisco-global-exploiter" class="headerlink" title="2.4 Cisco-global-exploiter"></a>2.4 Cisco-global-exploiter</h2><p>   Cisco-global-exploiter是一个小型的Perl脚本,是一个针对 思科设备的漏洞利用工具合集,支持对思科设备的14种独立的漏洞 进行测试。</p><h2 id="2-5-Cisco-torch"><a href="#2-5-Cisco-torch" class="headerlink" title="2.5 Cisco-torch"></a>2.5 Cisco-torch</h2><p>   Cisco-torch是一款专门针对思科设备的扫描工具,它具备多种 应用层协议的指纹识别特性，借助与第三方指纹库的比对，可以轻 松识别目标设备及系统类型。同时由于采用了多线程的开发方式， 所以在性能上torch也同样表现突出。另外在密码破解和漏洞利用 方面, torch也具备相应的能力。如果torch破解了设备读写权限的 SNMP Community,还可进一步利用其获取设备的完整配置信息。</p><h2 id="2-6-Copy-router-config"><a href="#2-6-Copy-router-config" class="headerlink" title="2.6 Copy-router-config"></a>2.6 Copy-router-config</h2><p>   Copy-router-config专门针对思科设备而设计,利用SNMP协议 下载和上传思科设备的配置文件。其使用需要tftp服务的配合。</p><h2 id="2-7-Lynis"><a href="#2-7-Lynis" class="headerlink" title="2.7 Lynis"></a>2.7 Lynis</h2><p>   Lynis是个系统安全检查工具,针对Unix和Linux系统而设计, 通过执行一些安全检查发现系统安装的软件以及存在的配置问题。它能生成一份全面的加固建议列表，并由使用者灵活地自行决定实 施哪些加固措施。</p><h2 id="2-8-Nessus"><a href="#2-8-Nessus" class="headerlink" title="2.8 Nessus"></a>2.8 Nessus</h2><p>   Nessus是世界上最流行的漏洞扫描程序,提供完整的电脑漏洞 扫描服务，并随时更新其漏洞数据库，可同时在本机或远端上遥控， 进行系统的漏洞分析扫描。它完整支持SSL,可自定义功能插件。</p><h2 id="2-9-OpenVAS"><a href="#2-9-OpenVAS" class="headerlink" title="2.9 OpenVAS"></a>2.9 OpenVAS</h2><p>   OpenVAS是目前开源世界最重要的漏洞管理产品,它基于各种安 全行业的标准规范，广泛覆盖了已知的漏洞类型。它使用简单方便， 可以自动发现系统中绝大部分已知漏洞，无论对于渗透测试者还是 安全运维工程师，这都是一个不能缺少的强大工具。</p><h1 id="3-漏洞利用工具"><a href="#3-漏洞利用工具" class="headerlink" title="3 漏洞利用工具"></a>3 漏洞利用工具</h1><p>   发现了操作系统、网络和应用服务的漏洞，接下来怎么利用这些漏洞发起攻击呢? Kali提供了许多漏洞利用工具，这些工具有些功能强大，可以利用的漏洞类型很多，甚至可以定制，针对新的漏洞可通过添加脚本的方式扩展其功能，如Metasploit；有些工具则是针对特定的漏洞具有很好的效果。Kali系统提供的漏洞利用工具如下表所示</p><h2 id="3-1-Armitage"><a href="#3-1-Armitage" class="headerlink" title="3.1 Armitage"></a>3.1 Armitage</h2><p>   Armitage是一款Java写的Metasploit图形界面化的攻击软 件,可以用它结合Metasploit中已知的exploit来针对主机存在 的漏洞自动化攻击。通过命令行的方式使用Metasploit难度较高, 需要记忆的命令过多,而Armitage完美地解决了这一问题,用户 只需要简单地点击菜单，就可以实现对目标主机的安全测试和攻 击。Armitage良好的图形展示界面,使得攻击过程更加直观,用 户体验更好。因其操作的简单性,尤其适合Metasploit初学者对 目标系统进行安全测试和攻击。</p><h2 id="3-2-Backdoor-Factory"><a href="#3-2-Backdoor-Factory" class="headerlink" title="3.2  Backdoor Factory"></a>3.2  Backdoor Factory</h2><p>   Backdoor Factory是一款安全测试工具,可以轻松地生成 win32PE后门测试程序,可对可执行文件进行自动化的后门部署。</p><h2 id="3-3-BeEF"><a href="#3-3-BeEF" class="headerlink" title="3.3 BeEF"></a>3.3 BeEF</h2><p>   BeEF(Browser Exploitation Framework)是一款针对浏览 器的渗透测试工具。</p><h2 id="3-4-Metasploit-Framework"><a href="#3-4-Metasploit-Framework" class="headerlink" title="3.4 Metasploit Framework"></a>3.4 Metasploit Framework</h2><p>   Metasploit Framework简称MSF,是一个用Ruby语言写的渗 透测试框架,该框架集成了很多可用的渗透利用工具(Exploit Tools)。用户可以在这个框架下进行一 系列的渗透测试,利用现有的装备(Payload),如Meterpreter 等进一步拿取对方的Shell。Metasploit功能强大,几乎每一个 从事渗透测试的人都会接触到它，是渗透测试的利器。</p><h2 id="3-5-Exploitdb"><a href="#3-5-Exploitdb" class="headerlink" title="3.5  Exploitdb"></a>3.5  Exploitdb</h2><p>   Exploitdb(Exploit Database)是一个由“Offebnsive Security”提供的漏洞利用程序集的数据库,可以用于平时的参 考和使用。它存储了大量的漏洞利用程序，可以帮助安全研究者 和渗透测试工程师更好地进行安全测试工作。</p><h1 id="4-嗅探与欺骗工具"><a href="#4-嗅探与欺骗工具" class="headerlink" title="4 嗅探与欺骗工具"></a>4 嗅探与欺骗工具</h1><h2 id="4-1-Burp-Suite"><a href="#4-1-Burp-Suite" class="headerlink" title="4.1 Burp Suite"></a>4.1 Burp Suite</h2><p>   Burp Suite是Web应用程序测试的最佳工具之一,其功能强大,可 破解登陆表单，执行会话令牌等多种的随机性检查。以执行多种任务,如请求的拦截和修改,扫描web应用程序漏洞,以暴力破解登录表单，执行会话令牌等多种的随机性检查</p><h2 id="4-2-HexInject"><a href="#4-2-HexInject" class="headerlink" title="4.2 HexInject"></a>4.2 HexInject</h2><p>   HexInject是一款进行数据注入的工具,它可以直接向网络注入渗透 人员构造的数据包，也可以篡改网络传输的数据，为了避免修改带来的数 据验证问题，它默认对包进行校验，并重新计算包的大小，从而提高数据 的真实性。</p><h2 id="4-3-Inviteflood"><a href="#4-3-Inviteflood" class="headerlink" title="4.3  Inviteflood"></a>4.3  Inviteflood</h2><p>   Inviteflood攻击的目标是VoIP,它针对VoIP信令协议SIP中的 INVITE会话请求指令发起洪水攻击,被攻击者会瞬间接到大量呼叫请求, 导致类似电话占线的效果,严重时可令IP电话客户端程序崩溃。</p><h2 id="4-4-iSMTP"><a href="#4-4-iSMTP" class="headerlink" title="4.4 iSMTP"></a>4.4 iSMTP</h2><p>   iSMTP是一款SMTP用户枚举和测试工具。</p><h2 id="4-5-Mitmproxy"><a href="#4-5-Mitmproxy" class="headerlink" title="4.5 Mitmproxy"></a>4.5 Mitmproxy</h2><p>   Mitmproxy俗称中间人攻击的神器,是一款有篡改功能的http代理 工具,支持http通信与https通信,既可用于中间人攻击,也可用于 html抓包调试。mitmproxy共有五种代理模式:正向代理模式、反向代理 模式、上行代理模式、透明代理模式和socks5代理模式。</p><h2 id="4-6-SniffJoke"><a href="#4-6-SniffJoke" class="headerlink" title="4.6 SniffJoke"></a>4.6 SniffJoke</h2><p>   SniffJoke是一款网络防嗅探工具。在渗透测试中,通过网络嗅探, 可以获取网络通信主机的各种信息。SniffJoke可以防止嗅探,它能够自 动对用户的网络数据进行附加处理，如发包延时、修改部分包、注入无效 包，使得嗅探工具无法正确读取数据包，并且所有这些附加处理不会影响 数据接收方的处理。</p><h2 id="4-7-SSLstrip"><a href="#4-7-SSLstrip" class="headerlink" title="4.7 SSLstrip"></a>4.7 SSLstrip</h2><p>   SSLstrip也叫https降级攻击,攻击者拦截用户流量后,欺骗用 户与攻击者进行http通信,攻击者与服务器保持正常通信(http或 https),从而获取用户信息。</p><h2 id="4-8-WebScarab"><a href="#4-8-WebScarab" class="headerlink" title="4.8 WebScarab"></a>4.8 WebScarab</h2><p>   WebScarab是由开放式Web应用安全项目(OWASP)组开发的一个用 来分析使用HTTP和HTTPS协议的应用程序框架。WebScarab可以记录它 检测到的会话内容（请求和应答），并允许使用者通过多种形式来查看记 录。可以用它来调试程序中较难处理的漏洞，也可以帮助安全专家发现潜 在的程序漏洞。</p><h1 id="5-密码攻击工具"><a href="#5-密码攻击工具" class="headerlink" title="5 密码攻击工具"></a>5 密码攻击工具</h1><h2 id="5-1-BruteSpray"><a href="#5-1-BruteSpray" class="headerlink" title="5.1 BruteSpray"></a>5.1 BruteSpray</h2><p>   BruteSpray是一个基于Nmap扫描结果的端口爆破工具，它可以载入Nmap的扫描结果（gnmap&#x2F;XML文件），然后对我们指定的端口和IP进行枚举口令爆破，爆破过程可通过自动调用Medusa来进行。</p><h2 id="5-2-Cain-Abel"><a href="#5-2-Cain-Abel" class="headerlink" title="5.2  Cain&amp;Abel"></a>5.2  Cain&amp;Abel</h2><p>   Cain&amp;Abel 是由0xid.it开发的一个针对Microsoft操作系统的免费口令回复工具，号称穷人使用的LC，这是一款网络管理员必备的工具，它可以用来检测Windows，UNIX用户是否使用了不安全的密码。它的功能十分强大，可以进行网络嗅探、网络欺骗、破解加密口令、解码被打乱的口令、显示口令框、显示缓存口令和分析路由协议，甚至还可以监听内网中他人使用V0IP拨打电话。</p><h2 id="5-3-Crunch"><a href="#5-3-Crunch" class="headerlink" title="5.3 Crunch"></a>5.3 Crunch</h2><p>   Crunch是一款密码生成工具，可以按照指定的规则（用户可以指定字符集）生成密码字典。它可以产生所有有可能的组合和排列，其生成的字典字符序列可以输出到屏幕、文件或重定向到另一个程序中。</p><h2 id="5-4-Findmyhash"><a href="#5-4-Findmyhash" class="headerlink" title="5.4   Findmyhash"></a>5.4   Findmyhash</h2><p>   Findmyhash是一款可以破解哈希值的强大脚本，用python语言编写，如果用户希望破解一些难以理解的Hash值，使用Findmyhash脚本可以一键阅读出Hash值内的所有内容。</p><h2 id="5-5-Hash-Identifier"><a href="#5-5-Hash-Identifier" class="headerlink" title="5.5 Hash-Identifier"></a>5.5 Hash-Identifier</h2><p>   Hash-Identifier并不是Hash破解工具，而是用来判断Hash值所使用的加密方法的工具。</p><h2 id="5-6-Hydra"><a href="#5-6-Hydra" class="headerlink" title="5.6 Hydra"></a>5.6 Hydra</h2><p>   Hydra是由THC社区开发的一个在线快速破译密码工具，目的是为研究人员及安全顾问展示如何从远程侵入系统，其密码词库支持超过50种网络协议，包括Telnet、RDP、SSH、FTP、HTTP、HTTPS、SMB等等，还支持多种数据库的密码破译，Hydra-gtk是其图形用户界面版本。</p><h2 id="5-7-John-the-Ripper"><a href="#5-7-John-the-Ripper" class="headerlink" title="5.7 John the Ripper"></a>5.7 John the Ripper</h2><p>   John the Ripper是免费开源软件，是一个快速的密码破解工具，用于在已知密文的情况下尝试破解出明文的破解密码软件，支持目前大多数的加密算法，如DES、MD5等。它支持多种不同类型的系统架构，包括Unix，Linux，Windows，Dos模式、BeOs和openVMS，主要目的是破解不够牢固的Unix。Linux系统密码。</p><h2 id="5-8-Medusa"><a href="#5-8-Medusa" class="headerlink" title="5.8  Medusa"></a>5.8  Medusa</h2><p>   Medusa和Hydra一样是一款在线密码破解工具。优点是Medusa的稳定性较好，但Medusa支持的模块要比Hydra少很多，也不支持RDF服务协议。同时它的表单破解也存在一些问题。</p><h2 id="5-9-RainbowCrack"><a href="#5-9-RainbowCrack" class="headerlink" title="5.9 RainbowCrack"></a>5.9 RainbowCrack</h2><p>   RainbowCrack是一个使用内存时间交换技术加速口令破解过程的口令破解器。它使用了彩虹表也就是一张预先计算好的明文和散列值的对照表。通过预先花费时间创建这样的彩虹表，能够再以后破解口令时节约大量的时间</p><h2 id="5-10-Rtgen"><a href="#5-10-Rtgen" class="headerlink" title="5.10  Rtgen"></a>5.10  Rtgen</h2><p>   Rtgen工具用来生成彩虹表。彩虹表是一个庞大的，针对各种可能的字母组合预先计算好的哈希值的集合，不一定是针对MD5算法的，各种算法的都有，有了它可以快速地破解各种密码。越是复杂的密码，需要的彩虹表就越大，现在主流的彩虹表都是100G以上的。不同的加密方式要用不同的彩虹表。</p><h2 id="5-11-Samdump2"><a href="#5-11-Samdump2" class="headerlink" title="5.11 Samdump2"></a>5.11 Samdump2</h2><p>   Samdump2是一款破解Windows SAM 密码文件的工具。</p><h1 id="6-权限提升工具"><a href="#6-权限提升工具" class="headerlink" title="6 权限提升工具"></a>6 权限提升工具</h1><h2 id="6-1-Meterpreter"><a href="#6-1-Meterpreter" class="headerlink" title="6.1  Meterpreter"></a>6.1  Meterpreter</h2><p>   Meterpreter是一种后渗透工具，它属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型Payload。这种是基于“内存DLL注入”理念实现的，它能够通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。在Meterpreter中可以执行Getsystem命令快速提权，Meterpreter会自己尝试用多种方法去提升权限，使得用户只需要运行一条指令就能获得System权限。</p><h2 id="6-2-SET"><a href="#6-2-SET" class="headerlink" title="6.2 SET"></a>6.2 SET</h2><p>   SET是社会工程包，是一个为社会工程设计的开放源码的渗透测试框架。它有许多自定义攻击向量，允许用户快速发起可信攻击。</p><h1 id="7-Web-应用工具"><a href="#7-Web-应用工具" class="headerlink" title="7 Web 应用工具"></a>7 Web 应用工具</h1><h2 id="7-1-Arachni"><a href="#7-1-Arachni" class="headerlink" title="7.1  Arachni"></a>7.1  Arachni</h2><p>   Arachni是一个多功能、模块化、高性能的Ruby框架,旨 在帮助渗透测试人员和管理员评估Web应用程序的安全性。同时 Arachni开源免费,可安装在Windows、Linux以及Mac系统上,并 且可导出评估报告。</p><h2 id="7-2-BlindElephant"><a href="#7-2-BlindElephant" class="headerlink" title="7.2  BlindElephant"></a>7.2  BlindElephant</h2><p>   BlindElephant是一款Web应用程序指纹识别工具。该工具可 以读取目标网站的特定静态文件,计算其对应的哈希值,然后和预 先计算出的哈希值做对比,从而判断目标网站的类型和版本号。目 前,该工具支持15种常见的Web应用程序的几百个版本。同时, 它还提供WordPress和Joomla的各种插件。该工具还允许用户自 已扩展，添加更多的版本支持。</p><h2 id="7-3-CutyCapt"><a href="#7-3-CutyCapt" class="headerlink" title="7.3 CutyCapt"></a>7.3 CutyCapt</h2><p>   CutyCapt是基于Qt实现的跨平台的将HTML网页转化成矢量 图形和位图图像格式的命令行工具(比如,SVG、PDF、PS、PNG、 JPEG、TIFF、GIF等)。</p><h2 id="7-4-DIRB"><a href="#7-4-DIRB" class="headerlink" title="7.4 DIRB"></a>7.4 DIRB</h2><p>   DIRB是一个专门用于爆破目录的工具。</p><h2 id="7-5-Nikto"><a href="#7-5-Nikto" class="headerlink" title="7.5 Nikto"></a>7.5 Nikto</h2><p>   Nikto是一款开源的(GPL)网页服务器扫描器,它可以对网页 服务器进行全面的多种扫描,包含超过3300种有潜在危险的文件&#x2F; CGIs、超过625种服务器版本、超过230种特定服务器问题。</p><h2 id="7-6-Paros-Proxy"><a href="#7-6-Paros-Proxy" class="headerlink" title="7.6   Paros Proxy"></a>7.6   Paros Proxy</h2><p>   Paros Proxy是一个对Web应用程序的漏洞进行评估的代理程 序,它是一个基于Java的Web代理程序,可以评估Web应用程序 的漏洞。它支持动态地编辑&#x2F;查看HTTP&#x2F;HTTPS,从而改变cookies 和表单字段等项目。它包括一个Web通信记录程序、Web圈套程序、 hash计算器,还有一个可以测试常见的Web应用程序攻击的扫描器。该工具检查漏洞形式包括:SQL注入、跨站点脚本攻击、目录遍历等。</p><h2 id="7-7-ProxyStrike"><a href="#7-7-ProxyStrike" class="headerlink" title="7.7  ProxyStrike"></a>7.7  ProxyStrike</h2><p>   ProxyStrike是一款用于web漏洞扫描的工具，需要配置代理使用，带有爬虫模块、请求报告、日志、配置等功能模块</p><h2 id="7-8-Vega"><a href="#7-8-Vega" class="headerlink" title="7.8  Vega"></a>7.8  Vega</h2><p>   Vega是一个开放源代码的Word应用程序安全测试平台, Vega能够帮助验证SQL注入、跨站脚本、敏感信息泄露和其他一些安全漏洞。Vega使用Java编写,有GUI,可以在Linux、OS X和 Windows下运行。</p><h2 id="7-9-Webshag"><a href="#7-9-Webshag" class="headerlink" title="7.9 Webshag"></a>7.9 Webshag</h2><p>   Webshag是一个对Web服务器进行安全审计的跨平台多线程工具。Webshag会收集那些通常对Web服务器有用的功能,比如 Webshag是一个用于对Web服务器进行安全审计的跨平台多线 端口扫描、URL扫描和文件模糊测试。可以通过代理和HTTP身份认 证(基于认证或摘要认证),以HTTP或HTTPS的方式扫描Web服务器。此外Webshag可以凭借IDS规避能力,使请求之间的相关性变得更 复杂。</p><h2 id="7-10-WebSploit"><a href="#7-10-WebSploit" class="headerlink" title="7.10 WebSploit"></a>7.10 WebSploit</h2><p>   WebSploit是一个开源项目,主要用于远程扫描和分析系统漏 洞。使用它可以非常容易和快速发现系统中存在的问题，并用于深 入分析。</p><h2 id="7-11-Whatweb"><a href="#7-11-Whatweb" class="headerlink" title="7.11 Whatweb"></a>7.11 Whatweb</h2><p>   Whatweb是一个基于Ruby语言的开源网站指纹识别软件,正如 它的名字一样,Whatweb能够识别各种关于网站的详细信息,包括: CMS类型、博客平台、中间件、Web框架模块、网站服务器、脚本类型、 JavaScript库、IP、cookie等等。</p><h1 id="8-无线攻击工具"><a href="#8-无线攻击工具" class="headerlink" title="8 无线攻击工具"></a>8 无线攻击工具</h1><h2 id="8-1-Aircrack-ng"><a href="#8-1-Aircrack-ng" class="headerlink" title="8.1 Aircrack-ng"></a>8.1 Aircrack-ng</h2><p>   Aircrack-ng是一个与802.11标准的无线网络分析有关的 安全软件，主要功能有：虚拟管道创建、网络侦测、数据包嗅 探、WEP和WPA&#x2F;WPA2-PSK破解、essid密码列表的保存和管理。Aircrack-ng可以工作在任何支持监听模式的无线网卡上并嗅探 802.11b,802.11b,802.11g的数据。该程序可运行在Linux和 Windows上。</p><h2 id="8-2-Arpspoof"><a href="#8-2-Arpspoof" class="headerlink" title="8.2 Arpspoof"></a>8.2 Arpspoof</h2><p>   Arpspoof是一款专业的ARP断网攻击软件,能够直接欺骗网 关,使得通过网关访问网络的电脑全被欺骗攻击,通过ARP欺骗 达到中间人嗅探和捕获网络数据包的目的，并替换传输中的数据， 方便用户开启ARP断网攻击,抢占网速。</p><h2 id="8-3-Easy-Creds"><a href="#8-3-Easy-Creds" class="headerlink" title="8.3 Easy-Creds"></a>8.3 Easy-Creds</h2><p>   Easy-Creds是一款欺骗嗅探为主的攻击脚本工具,它具备 ARP毒化、DNS毒化等一些嗅探攻击模式。它最亮的地方就是它 的fake AP(欺骗访问点)功能。它比一般自行搭建的fake AP 要稳定得多,而且里面还包含了针对802.1x的攻击模式。</p><h2 id="8-4-Gerix-Wifi-Cracker"><a href="#8-4-Gerix-Wifi-Cracker" class="headerlink" title="8.4 Gerix Wifi Cracker"></a>8.4 Gerix Wifi Cracker</h2><p>   Gerix Wifi Cracker是一个aircrack图形用户界面的无线 网络破解工具，可破解无线网络密码。</p><h2 id="8-5-Kismet"><a href="#8-5-Kismet" class="headerlink" title="8.5 Kismet"></a>8.5 Kismet</h2><p>   Kismet是一款802.11二层无线网络探测器、嗅探器和入侵 检测系统，使用该工具可以检测周围的无线信号，并查看所有可 用的无线接入点,并能嗅出802.11a&#x2F;b&#x2F;g&#x2F;n的流量。</p><h2 id="8-6-Reaver"><a href="#8-6-Reaver" class="headerlink" title="8.6 Reaver"></a>8.6 Reaver</h2><p>   Reaver是一款针对开启Wi-Fi安全防护设定(Wi-Fi Protected Setup,WPS)服务的无线网络的破解工具。</p><h2 id="8-7-Wifte"><a href="#8-7-Wifte" class="headerlink" title="8.7  Wifte"></a>8.7  Wifte</h2><p>   Wifte是一款使用Aircrack-ng工具集来破解无线网络的带 图形用户界面的工具,是一款自动化WEP、WPA以及WPS破解工具, 特点是可以同时攻击多个采用WEP和WPA加密的网络。</p><h1 id="9-维持访问工具"><a href="#9-维持访问工具" class="headerlink" title="9 维持访问工具"></a>9 维持访问工具</h1><h2 id="9-1-Cryptcat"><a href="#9-1-Cryptcat" class="headerlink" title="9.1  Cryptcat"></a>9.1  Cryptcat</h2><p>   Cryptcat是网络工具Netcat的加密版本。Cryptcat支持TCP、UDP两种 网络协议。它可以在两个计算机之间建立指定的连接，并使用特定的密钥对 传输数据进行加密。为了提高加密效果，该工具允许用户在每次连接时使用 自定义的密钥，从而保证数据的安全性。</p><h2 id="9-2-Cymothoa"><a href="#9-2-Cymothoa" class="headerlink" title="9.2  Cymothoa"></a>9.2  Cymothoa</h2><p>   Cymothoa是一款可以将ShellCode注入现有进程(插入进程)的后门工具。借助这种注入手段,它能够把ShellCode伪装成常规程序。它所注入的后门 程序能够与被注入的程序共存,以避免被管理或维护人员怀疑。将ShellCode 注入其他进程，还有另外一个优势就是：即使目标系统的安全防护工具能够 检验可执行程序的完整性，只要它不检查内存，就不能发现后门程序的进程。</p><h2 id="9-3-Intersect"><a href="#9-3-Intersect" class="headerlink" title="9.3  Intersect"></a>9.3  Intersect</h2><p>   Intersect是一款适合在漏洞利用以后使用的能够自动完成多种后期任 务的程序。它能够自动收集密码文件、赋值SSH密钥、收集网络信息,并能 识别杀毒软件和防火墙程序。若要它自动执行后期任务，用户需要创建自己 的脚本文件,脚本中指定需要执行的各种功能。对于Inetersect来说,每个 功能都有对应的执行模块。</p><h2 id="9-4-NetCat"><a href="#9-4-NetCat" class="headerlink" title="9.4 NetCat"></a>9.4 NetCat</h2><p>   NetCat是一个非常简单的Unix工具,可以读、写TCP或UDP网络连接 (Network Connection)。它被设计成一个可靠的后端(Back-End)工具, 能被其他的程序或脚本直接地或容易地驱动。同时，它又是一个功能丰富的 网络调试和开发工具，因为它可以建立用户可能用到的几乎任何类型的连接， 以及一些非常有意思的内建功能。</p><h2 id="9-5-Weevely"><a href="#9-5-Weevely" class="headerlink" title="9.5 Weevely"></a>9.5 Weevely</h2><p>   Weevely是一款针对PHP的webshell的自由软件,可用于模拟一个类似 于Telnet的连接shell, Weevely通常用于Web程序的漏洞利用,隐藏后门 或者使用类似Telnet的方式来代替Web页面式的管理, Weevely生成的服 务器端php代码是经过了base64编码的,所以可以骗过主流的杀毒软件和 IDS,上传服务器端代码后通常可以通过Weevely直接运行。</p><h1 id="10-取证工具"><a href="#10-取证工具" class="headerlink" title="10 取证工具"></a>10 取证工具</h1><h2 id="10-1-Bulk-extractor"><a href="#10-1-Bulk-extractor" class="headerlink" title="10.1 Bulk _ extractor"></a>10.1 Bulk _ extractor</h2><p>   Bulk _ extractor是从数字证据文件中提取诸如电子邮件地址、信 用卡号、URL和其他类型的信息的功能的程序。它是一个有用的取证 调查工具，可以用于许多任务，如恶意软件和入侵调查、身份调查和 网络调查，以及图像分析和密码破解。</p><h2 id="10-2-Capstone"><a href="#10-2-Capstone" class="headerlink" title="10.2 Capstone"></a>10.2 Capstone</h2><p>   Capstone是一款优秀的反汇编框架,支持多种CPU架构,支持多 个平台，提供反汇编指令的语义详情，用一个授权许可便可以为所有 重要编程语言提供捆包等。</p><h2 id="10-3-Dumpzilla"><a href="#10-3-Dumpzilla" class="headerlink" title="10.3  Dumpzilla"></a>10.3  Dumpzilla</h2><p>   Dumpzilla是用Python3开发的,目的是提取Firefox, Iceweasel和Seamonkey浏览器的相关信息进行分析。它在Unix和 Windows 32&#x2F;64位系统下工作,采用命令行界面,所以信息可以通过 管道重定向工具(如grep, awk, cut, sed)进行转储。</p><h2 id="10-4-Galeta"><a href="#10-4-Galeta" class="headerlink" title="10.4 Galeta"></a>10.4 Galeta</h2><p>   Galeta是一个取证工具,用于检查微软公司Internet Explorer 生产的Cookie文件的内容。它解析文件并输出可以在电子表格中加载 的字段。</p><h2 id="10-5-Peepdf"><a href="#10-5-Peepdf" class="headerlink" title="10.5  Peepdf"></a>10.5  Peepdf</h2><p>   Peepdf是一个用Python开发的、集成了多个组件的、用于检测 和分析PDF文件是否有害的取证工具。</p><h2 id="10-6-RegRipper"><a href="#10-6-RegRipper" class="headerlink" title="10.6 RegRipper"></a>10.6 RegRipper</h2><p>   RegRipper是一款用来对Windows操作系统的注册表进行取证的工具。</p><h2 id="10-7-Volatility"><a href="#10-7-Volatility" class="headerlink" title="10.7 Volatility"></a>10.7 Volatility</h2><p>   Volatility是开源的Windows, linux，Mac, Android的内存取 证分析工具、由Python编写成,命令行操作,支持各种操作系统。</p><h1 id="11-逆向工程工具"><a href="#11-逆向工程工具" class="headerlink" title="11 逆向工程工具"></a>11 逆向工程工具</h1><h2 id="11-1-DiStorm3"><a href="#11-1-DiStorm3" class="headerlink" title="11.1 DiStorm3"></a>11.1 DiStorm3</h2><p>   DiStorm3是Kali Linux自带的一款轻量级、容易使用的反汇编 引擎。它可以反汇编生成16位、32位和64位指令。它支持的指令 集包括FPU、MMX、SSE、SSE2、SSE3、SSSE3、SSE4、x86-64、VMX、 AMDs、SVM等。虽然diStorm3采用C语言编写,但可以被Python、 Ruby、Java快速封装。这样,用户可以使用Python、Rudy等脚本语言编写脚本，并引入diStorm33，从而定制自己的反汇编工具。</p><h2 id="11-2-Edb-debugger"><a href="#11-2-Edb-debugger" class="headerlink" title="11.2    Edb-debugger"></a>11.2    Edb-debugger</h2><p>   Edb-debugger是一个跨平台的x86&#x2F;x86-64调试器。它受到 Ollydbg的启发,但是其目标是在x86和x86-64以及多个操作系 统上运行。Linux是目前edb-debugger唯一官方支持的平台,但 FreeBSD,OpenBSD,OSX和Windows端口正在进行不同程度的功能实现。</p><h2 id="11-3-Flasm"><a href="#11-3-Flasm" class="headerlink" title="11.3 Flasm"></a>11.3 Flasm</h2><p>   Flasm可以对Flash的SWF文件进行拆解,包括所有的时间表和 事件。通过反汇编,用户可以了解Flash编译器的工作原理,从而提 高用户的ActionScript技能。用户也可以手动对反汇编代码进行优 化,或者根据需要调整代码,然后利用Flasm将用户的更改应用于原 SWF,替换原始操作</p><h2 id="11-4-JavaSnoop"><a href="#11-4-JavaSnoop" class="headerlink" title="11.4  JavaSnoop"></a>11.4  JavaSnoop</h2><p>   JavaSnoop是一个java应用程序安全测试工具，它允许已拦截的方法,篡改数据和hack运行在计算机上的java应用程序。通常在没 JavaSnoop是一个java应用程序安全测试工具,它允许以拦截的 有源代码的情况下,测试java客户端的安全性是不可预知的。在有源 代码的情况下,可以运行一个简单的java程序,并在远程附加一个调 试器来调试它,单步运行,根据需要改变变量,但对于一个applet来 说要想做到这一点是有点困难的。有时，可能需要修改客户端和服务 器之间的通信，一般的做法是在客户端配置一个代理，在代理上修改 数据。问题的关键是，通信的数据通常不是明文的，可能使用了自定 义的协议、序列化的对象、加密的数据或者多种方式混合应用。这样 要想修改通信过程中的数据是比较困难的。JavaSnoop试图解决这些 问题，它可直接附加到一个运行中的进程，类似于调试器，然后，篡 改方法调用、运行自定义代码或者对系统进行监视。</p><h2 id="11-5-011yDbg"><a href="#11-5-011yDbg" class="headerlink" title="11.5 011yDbg"></a>11.5 011yDbg</h2><p>   011yDbg是一个新的动态追踪工具,将IDA与SoftICE结合起来, Ring 3级调试器,非常容易上手,已代替SoftICE成为当今最为流行 的调试解密工具。同时还支持插件扩展功能，是目前最强大的调试工具。</p><p>   Valgrind是一款用于内存调试、内存泄漏检测以及性能分析的软 件开发工具。</p><h2 id="11-6-压力测试工具"><a href="#11-6-压力测试工具" class="headerlink" title="11.6 压力测试工具"></a>11.6 压力测试工具</h2><h2 id="11-7-DHCPig"><a href="#11-7-DHCPig" class="headerlink" title="11.7 DHCPig"></a>11.7 DHCPig</h2><p>   DHCPig可以发起一个高级的DHCP耗尽攻击。它将消耗局域网内的所 有IP地址以及阻止新客户端获取IP,同时它也防止旧客户端释放IP地址。另外,它会发送无效的ARP去把所有的Windows主机震下线。</p><h2 id="11-8-FunkLoad"><a href="#11-8-FunkLoad" class="headerlink" title="11.8  FunkLoad"></a>11.8  FunkLoad</h2><p>   FunkLoad是一个功能和负载的Web测试仪,主要用于Web项目,对网 站项目进行功能测试、性能测试、负载测试（如音量的测试或寿命测试） 和压力测试。</p><h2 id="11-9-IAX"><a href="#11-9-IAX" class="headerlink" title="11.9  IAX"></a>11.9  IAX</h2><p>   IAX是Inter-Asterisk eXchange的缩写,也就是Asterisk内部交换 协议。iaxflood则是利用IAX设计缺陷而发起洪水式攻击的工具。</p><h2 id="11-10-Inundator"><a href="#11-10-Inundator" class="headerlink" title="11.10 Inundator"></a>11.10 Inundator</h2><p>   Inundator是一个支持多目标的、多线程的、队列驱动的、匿名的、 误用入侵检测系统。</p><h2 id="11-11-MDK3"><a href="#11-11-MDK3" class="headerlink" title="11.11   MDK3"></a>11.11   MDK3</h2><p>   MDK3是一款无线DOS攻击测试工具,能够发起Beacon Flood、 Authentication DoS、Deauthentication&#x2F;Disassociation Amok等模式的 攻击,另外它还具有针对隐藏ESSID的暴力探测模式、802.1X渗透测试、 WIDS干扰等功能。</p><h2 id="11-12-Rtpflood"><a href="#11-12-Rtpflood" class="headerlink" title="11.12 Rtpflood"></a>11.12 Rtpflood</h2><p>   Rtpflood可以洪水攻击RTP通话设备,实现拒绝服务的效果。</p><h2 id="11-13-Inviteflood"><a href="#11-13-Inviteflood" class="headerlink" title="11.13 Inviteflood"></a>11.13 Inviteflood</h2><p>   Inviteflood通过TCP&#x2F;UDP进行泛洪攻击的SIP&#x2F;SDP会话,该工具可 以在本机产生大量的流量，因为需要在本地读取数据进行对外发送。所以 在流量监控时可能会产生40M&#x2F;s的速度。</p><h2 id="11-14-SlowHTTPTest"><a href="#11-14-SlowHTTPTest" class="headerlink" title="11.14 SlowHTTPTest"></a>11.14 SlowHTTPTest</h2><p>   SlowHTTPTest是依赖HTTP协议的慢速攻击DoS攻击工具,设计的基 本原理是服务器在请求完全接收后才会进行处理，如果客户端的发送速度 缓慢或者发送不完整，服务端为其保留连接资源池占用，大量此类请求并 发将导致DoS。</p><h2 id="11-15-THC-SSL-DOS"><a href="#11-15-THC-SSL-DOS" class="headerlink" title="11.15 THC-SSL-DOS"></a>11.15 THC-SSL-DOS</h2><p>   THC-SSL-DOS是一款针对SSL的压力测试工具。该工具默认会同服务 器建立400个SSL连接,并且快速进行重新协商Renegotiations,以达到 大量消耗服务器CPU资源的目的。该工具目前只针对开启重新协商功能的 服务器，所以只要关闭该功能，就可以抵御该工具的攻击。</p><h1 id="12-报告工具"><a href="#12-报告工具" class="headerlink" title="12 报告工具"></a>12 报告工具</h1><h2 id="12-1-CaseFile"><a href="#12-1-CaseFile" class="headerlink" title="12.1 CaseFile"></a>12.1 CaseFile</h2><p>   CaseFile是Maltego的姊妹工具,功能非常类似于Maltego。CaseFile主要针对数据进行离线分析,缺少Maltego的数据采集功能。它可以导入各类数据,包括Maltego导出的数据。用户可以为信息添 加连接线、标签和注释,标记数据的关系。CaseFile以图形化的方式 展现数据，方便分析人员找出隐含的数据关系。</p><h2 id="12-2-CherryTree"><a href="#12-2-CherryTree" class="headerlink" title="12.2 CherryTree"></a>12.2 CherryTree</h2><p>   CherryTree支持富文本编辑和代码高亮,支持Linux和Windows平台。数据采用 CherryTree是一个支持无限层级分类的笔记软件,由Python编与, sqlite或XML存储,支持密码保护。支持从NoteCase、KeepNote、Knowit、Tomboy、TuxCards、Treepad、Leo等笔记软件导入数据。</p><h2 id="12-3-Dos2unix"><a href="#12-3-Dos2unix" class="headerlink" title="12.3 Dos2unix"></a>12.3 Dos2unix</h2><p>   Dos2unix命令用来将DOS格式的文本文件转换成UNIX格式的文 本。</p><h2 id="12-4-Dradis"><a href="#12-4-Dradis" class="headerlink" title="12.4 Dradis"></a>12.4 Dradis</h2><p>   Dradis框架是一个开源的、用Ruby开发的协作和报告平台。可生成渗透测试报告，内容包括所提供的服务、使用的方法、发现的结 果和建议。</p><h2 id="12-5-MagicTree"><a href="#12-5-MagicTree" class="headerlink" title="12.5  MagicTree"></a>12.5  MagicTree</h2><p>   MagicTree是一个面向渗透测试人员的工具,可以帮助用户轻松 直接地进行数据合并、查询、外部命令执行和报告生成，所有的数据 都会以树形结构存储，非常方便。</p><h2 id="12-6-Metagoofil"><a href="#12-6-Metagoofil" class="headerlink" title="12.6 Metagoofil"></a>12.6 Metagoofil</h2><p>   Metagoofil是一款利用Google收集信息的工具,目前支持的文件类型有Word、PPT、Excel和PDF,结果可生成HTML报告文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-信息收集&quot;&gt;&lt;a href=&quot;#1-信息收集&quot; class=&quot;headerlink&quot; title=&quot;1 信息收集&quot;&gt;&lt;/a&gt;1 信息收集&lt;/h1&gt;&lt;h2 id=&quot;1-1-Amap&quot;&gt;&lt;a href=&quot;#1-1-Amap&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="安全工具集" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="安全工具" scheme="http://suzi007.github.io/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>AST还原</title>
    <link href="http://suzi007.github.io/2024/04/17/AST%E8%BF%98%E5%8E%9F/"/>
    <id>http://suzi007.github.io/2024/04/17/AST%E8%BF%98%E5%8E%9F/</id>
    <published>2024-04-17T07:11:11.000Z</published>
    <updated>2024-04-28T16:40:56.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-学习网站"><a href="#1-学习网站" class="headerlink" title="1 学习网站"></a>1 学习网站</h1><ul><li><a href="https://blogz.gitee.io/ast/">AST explorer 国内镜像</a></li><li><a href="https://astexplorer.net/">AST explorer</a> ，一个在线解析 AST 的网站。</li><li><a href="https://obfuscator.io/">ob 混淆工具官网</a>，可以用它的 demo 检测下自己的 AST 水准</li><li><a href="http://tool.yuanrenxue.com/">猿人学爬虫工具合集</a></li></ul><h1 id="2-基本组件"><a href="#2-基本组件" class="headerlink" title="2 基本组件"></a>2 基本组件</h1><h2 id="2-1-parser"><a href="#2-1-parser" class="headerlink" title="2.1 parser"></a>2.1 parser</h2><blockquote><p>描述：将 js 代码转换为抽象语法树<br>用法：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parse = <span class="built_in">require</span>(<span class="string">&quot;@babel/parser&quot;</span>).<span class="property">parse</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> traverse = <span class="built_in">require</span>(<span class="string">&quot;@babel/traverse&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-generator"><a href="#2-2-generator" class="headerlink" title="2.2 generator"></a>2.2 generator</h2><blockquote><p>描述：将抽象语法树还原为 JS 代码<br>用法：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generate = <span class="built_in">require</span>(<span class="string">&quot;@babel/generator&quot;</span>).<span class="property">default</span></span><br><span class="line"><span class="title function_">generate</span>(ast).<span class="property">code</span></span><br></pre></td></tr></table></figure><h2 id="2-3-traverse"><a href="#2-3-traverse" class="headerlink" title="2.3 traverse"></a>2.3 traverse</h2><blockquote><p>描述：遍历 node 节点<br>用法：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast,&#123;</span><br><span class="line"><span class="title class_">StringInditify</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//方式二 enter 和 exit的区别</span></span><br><span class="line"><span class="title function_">traverse</span>(ast,&#123;</span><br><span class="line"><span class="title class_">StringInditify</span>: &#123;</span><br><span class="line"><span class="attr">exit</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="3-基本属性"><a href="#3-基本属性" class="headerlink" title="3 基本属性"></a>3 基本属性</h1><h2 id="3-1-Path"><a href="#3-1-Path" class="headerlink" title="3.1 Path"></a>3.1 Path</h2><h2 id="属性：-path-replaceWith-把这个节点替换成另外一个节点，-接收参数为-node-path-node获取当前路径对应的节点。-path-parent获取当前路径对应节点的父节点。-path-parentPath获取当前路径对应节点的父路径。-path-scope表示当前-path-下的作用域，这个也是写插件经常会用到的。-path-container用于获取当前-path-下的所有兄弟节点-包括自身-。-path-type获取当前-path-的节点类型。-path-key获取当前-path-的-key-值，key-通常用于-path-get-函数。函数：-path-get-key-获取当前路径下指定属性名（key）对应的子路径。例如，path-get-“body”-获取当前路径下名为-“body”-的子路径。-path-getSibling-index-获取当前路径对应节点的兄弟节点的路径。通过指定索引（index）可以获取相应的兄弟路径。-path-getFunctionParent-获取当前路径对应节点的最近的函数父节点的路径。-path-getPrevSibling-获取当前-path-的前一个兄弟节点，返回的是-path-类型。-path-getAllPrevSiblings-获取当前-path-的所有前兄弟节点，返回的是-Array-类型，其元素都是-path-类型。-path-getNextSibling-获取当前-path-的后一个兄弟节点，返回的是-path-类型。-path-getAllNextSiblings-获取当前-path-的所有后兄弟节点，返回的是-Array-类型，其元素都是-path-类型。-path-evaluate-用于计算表达式的值，大家可以参考-constantFold-插件的写法。-path-findParent-向上查找满足回调函数特征的-path，即判断上级路径是否包含有-XXX-类型的节点。-path-find-功能与-path-findParent-方法一样，只不过从当前-path-开始进行遍历。-path-getFunctionParent-获取函数类型父节点，如果不存在，返回-null。-path-getStatementParent-获取-Statement-类型父节点，这个基本上都会有返回值，如果当前遍历的是-Program-或者-File-节点，则会报错。-path-getAncestry-获取所有的祖先节点，没有实参，返回的是一个-Array-对象。-path-isAncestor-maybeDescendant-判断当前遍历的节点是否为实参的祖先节点-path-isDescendant-maybeAncestor-判断当前遍历的节点是否为实参的子孙节点-path-traverse-visitor-遍历当前路径下的所有子节点，并应用指定的-visitor。-path-replaceWith-node-用指定的节点替换当前路径对应的节点。-path-remove-从-AST-中移除当前路径对应的节点。-path-insertBefore-nodes-在当前路径对应节点之前插入一个或多个节点。-path-insertAfter-nodes-在当前路径对应节点之后插入一个或多个节点。-path-toString-用于将-AST-节点转换回对应的源代码字符串。-3-2-Scope函数：-scope-block表示当前作用域下的所有-node，参考上面的-this-block-node-scope-dump-输出当前每个变量的作用域信息。调用后直接打印，不需要加打印函数-scope-crawl-重构-scope，在某种情况下会报错，不过还是建议在每一个插件的最后一行加上。-scope-rename-oldName-newName-block-修改当前作用域下的的指定的变量名，oldname、newname-表示替换前后的变量名，为字符串。注意，oldName-需要有-binding，否则无法重命名。-scope-traverse-node-opts-state-遍历当前作用域下的某些-个-插件。和全局的-traverse-用法一样。-scope-getBinding-name-获取某个变量的-binding，可以理解为其生命周期。包含引用，修改之类的信息属性：-scope-block-可以用来获取标识符的作用域，返回-Node-对象，使用方法分为两种情况：变量-和-函数-变量获取当前作用域，函数获取函数本身作用域。"><a href="#属性：-path-replaceWith-把这个节点替换成另外一个节点，-接收参数为-node-path-node获取当前路径对应的节点。-path-parent获取当前路径对应节点的父节点。-path-parentPath获取当前路径对应节点的父路径。-path-scope表示当前-path-下的作用域，这个也是写插件经常会用到的。-path-container用于获取当前-path-下的所有兄弟节点-包括自身-。-path-type获取当前-path-的节点类型。-path-key获取当前-path-的-key-值，key-通常用于-path-get-函数。函数：-path-get-key-获取当前路径下指定属性名（key）对应的子路径。例如，path-get-“body”-获取当前路径下名为-“body”-的子路径。-path-getSibling-index-获取当前路径对应节点的兄弟节点的路径。通过指定索引（index）可以获取相应的兄弟路径。-path-getFunctionParent-获取当前路径对应节点的最近的函数父节点的路径。-path-getPrevSibling-获取当前-path-的前一个兄弟节点，返回的是-path-类型。-path-getAllPrevSiblings-获取当前-path-的所有前兄弟节点，返回的是-Array-类型，其元素都是-path-类型。-path-getNextSibling-获取当前-path-的后一个兄弟节点，返回的是-path-类型。-path-getAllNextSiblings-获取当前-path-的所有后兄弟节点，返回的是-Array-类型，其元素都是-path-类型。-path-evaluate-用于计算表达式的值，大家可以参考-constantFold-插件的写法。-path-findParent-向上查找满足回调函数特征的-path，即判断上级路径是否包含有-XXX-类型的节点。-path-find-功能与-path-findParent-方法一样，只不过从当前-path-开始进行遍历。-path-getFunctionParent-获取函数类型父节点，如果不存在，返回-null。-path-getStatementParent-获取-Statement-类型父节点，这个基本上都会有返回值，如果当前遍历的是-Program-或者-File-节点，则会报错。-path-getAncestry-获取所有的祖先节点，没有实参，返回的是一个-Array-对象。-path-isAncestor-maybeDescendant-判断当前遍历的节点是否为实参的祖先节点-path-isDescendant-maybeAncestor-判断当前遍历的节点是否为实参的子孙节点-path-traverse-visitor-遍历当前路径下的所有子节点，并应用指定的-visitor。-path-replaceWith-node-用指定的节点替换当前路径对应的节点。-path-remove-从-AST-中移除当前路径对应的节点。-path-insertBefore-nodes-在当前路径对应节点之前插入一个或多个节点。-path-insertAfter-nodes-在当前路径对应节点之后插入一个或多个节点。-path-toString-用于将-AST-节点转换回对应的源代码字符串。-3-2-Scope函数：-scope-block表示当前作用域下的所有-node，参考上面的-this-block-node-scope-dump-输出当前每个变量的作用域信息。调用后直接打印，不需要加打印函数-scope-crawl-重构-scope，在某种情况下会报错，不过还是建议在每一个插件的最后一行加上。-scope-rename-oldName-newName-block-修改当前作用域下的的指定的变量名，oldname、newname-表示替换前后的变量名，为字符串。注意，oldName-需要有-binding，否则无法重命名。-scope-traverse-node-opts-state-遍历当前作用域下的某些-个-插件。和全局的-traverse-用法一样。-scope-getBinding-name-获取某个变量的-binding，可以理解为其生命周期。包含引用，修改之类的信息属性：-scope-block-可以用来获取标识符的作用域，返回-Node-对象，使用方法分为两种情况：变量-和-函数-变量获取当前作用域，函数获取函数本身作用域。" class="headerlink" title="属性：- path.replaceWith 把这个节点替换成另外一个节点， 接收参数为 node- path.node获取当前路径对应的节点。- path.parent获取当前路径对应节点的父节点。- path.parentPath获取当前路径对应节点的父路径。- path.scope表示当前 path 下的作用域，这个也是写插件经常会用到的。- path.container用于获取当前 path 下的所有兄弟节点(包括自身)。- path.type获取当前 path 的节点类型。- path.key获取当前 path 的 key 值，key 通常用于 path.get 函数。函数：- path.get(key)获取当前路径下指定属性名（key）对应的子路径。例如，path.get(“body”) 获取当前路径下名为 “body” 的子路径。- path.getSibling(index)获取当前路径对应节点的兄弟节点的路径。通过指定索引（index）可以获取相应的兄弟路径。- path.getFunctionParent()获取当前路径对应节点的最近的函数父节点的路径。- path.getPrevSibling()获取当前 path 的前一个兄弟节点，返回的是 path 类型。- path.getAllPrevSiblings()获取当前 path 的所有前兄弟节点，返回的是 Array 类型，其元素都是 path 类型。- path.getNextSibling()获取当前 path 的后一个兄弟节点，返回的是 path 类型。- path.getAllNextSiblings()获取当前 path 的所有后兄弟节点，返回的是 Array 类型，其元素都是 path 类型。- path.evaluate()用于计算表达式的值，大家可以参考 constantFold 插件的写法。- path.findParent()向上查找满足回调函数特征的 path，即判断上级路径是否包含有 XXX 类型的节点。- path.find()功能与 path.findParent 方法一样，只不过从当前 path 开始进行遍历。- path.getFunctionParent()获取函数类型父节点，如果不存在，返回 null。- path.getStatementParent()获取 Statement 类型父节点，这个基本上都会有返回值，如果当前遍历的是 Program 或者 File 节点，则会报错。- path.getAncestry()获取所有的祖先节点，没有实参，返回的是一个 Array 对象。- path.isAncestor(maybeDescendant)判断当前遍历的节点是否为实参的祖先节点.- path.isDescendant(maybeAncestor)判断当前遍历的节点是否为实参的子孙节点.- path.traverse(visitor)遍历当前路径下的所有子节点，并应用指定的 visitor。- path.replaceWith(node)用指定的节点替换当前路径对应的节点。- path.remove()从 AST 中移除当前路径对应的节点。- path.insertBefore(nodes)在当前路径对应节点之前插入一个或多个节点。- path.insertAfter(nodes)在当前路径对应节点之后插入一个或多个节点。- path.toString()用于将 AST 节点转换回对应的源代码字符串。## 3.2 Scope函数：- scope.block表示当前作用域下的所有 node，参考上面的 this.block &#x3D; node;- scope.dump()输出当前每个变量的作用域信息。调用后直接打印，不需要加打印函数- scope.crawl()重构 scope，在某种情况下会报错，不过还是建议在每一个插件的最后一行加上。- scope.rename(oldName, newName, block)修改当前作用域下的的指定的变量名，oldname、newname 表示替换前后的变量名，为字符串。注意，oldName 需要有 binding，否则无法重命名。- scope.traverse(node, opts, state)遍历当前作用域下的某些(个)插件。和全局的 traverse 用法一样。- scope.getBinding(name)获取某个变量的 binding，可以理解为其生命周期。包含引用，修改之类的信息属性：- scope.block 可以用来获取标识符的作用域，返回 Node 对象，使用方法分为两种情况：变量 和 函数,变量获取当前作用域，函数获取函数本身作用域。"></a>属性：<br>- path.replaceWith 把这个节点替换成另外一个节点， 接收参数为 node<br>- path.node获取当前路径对应的节点。<br>- path.parent获取当前路径对应节点的父节点。<br>- path.parentPath获取当前路径对应节点的父路径。<br>- path.scope表示当前 path 下的作用域，这个也是写插件经常会用到的。<br>- path.container用于获取当前 path 下的所有兄弟节点(包括自身)。<br>- path.type获取当前 path 的节点类型。<br>- path.key获取当前 path 的 key 值，key 通常用于 path.get 函数。<br>函数：<br>- path.get(key)获取当前路径下指定属性名（key）对应的子路径。例如，path.get(“body”) 获取当前路径下名为 “body” 的子路径。<br>- path.getSibling(index)获取当前路径对应节点的兄弟节点的路径。通过指定索引（index）可以获取相应的兄弟路径。<br>- path.getFunctionParent()获取当前路径对应节点的最近的函数父节点的路径。<br>- path.getPrevSibling()获取当前 path 的前一个兄弟节点，返回的是 path 类型。<br>- path.getAllPrevSiblings()获取当前 path 的所有前兄弟节点，返回的是 Array 类型，其元素都是 path 类型。<br>- path.getNextSibling()获取当前 path 的后一个兄弟节点，返回的是 path 类型。<br>- path.getAllNextSiblings()获取当前 path 的所有后兄弟节点，返回的是 Array 类型，其元素都是 path 类型。<br>- path.evaluate()用于计算表达式的值，大家可以参考 constantFold 插件的写法。<br>- path.findParent()向上查找满足回调函数特征的 path，即判断上级路径是否包含有 XXX 类型的节点。<br>- path.find()功能与 path.findParent 方法一样，只不过从当前 path 开始进行遍历。<br>- path.getFunctionParent()获取函数类型父节点，如果不存在，返回 null。<br>- path.getStatementParent()获取 Statement 类型父节点，这个基本上都会有返回值，如果当前遍历的是 Program 或者 File 节点，则会报错。<br>- path.getAncestry()获取所有的祖先节点，没有实参，返回的是一个 Array 对象。<br>- path.isAncestor(maybeDescendant)判断当前遍历的节点是否为实参的祖先节点.<br>- path.isDescendant(maybeAncestor)判断当前遍历的节点是否为实参的子孙节点.<br>- path.traverse(visitor)遍历当前路径下的所有子节点，并应用指定的 visitor。<br>- path.replaceWith(node)用指定的节点替换当前路径对应的节点。<br>- path.remove()从 AST 中移除当前路径对应的节点。<br>- path.insertBefore(nodes)在当前路径对应节点之前插入一个或多个节点。<br>- path.insertAfter(nodes)在当前路径对应节点之后插入一个或多个节点。<br>- path.toString()用于将 AST 节点转换回对应的源代码字符串。<br>## 3.2 Scope<br>函数：<br>- scope.block表示当前作用域下的所有 node，参考上面的 this.block &#x3D; node;<br>- scope.dump()输出当前每个变量的作用域信息。调用后直接打印，不需要加打印函数<br>- scope.crawl()重构 scope，在某种情况下会报错，不过还是建议在每一个插件的最后一行加上。<br>- scope.rename(oldName, newName, block)修改当前作用域下的的指定的变量名，oldname、newname 表示替换前后的变量名，为字符串。注意，oldName 需要有 binding，否则无法重命名。<br>- scope.traverse(node, opts, state)遍历当前作用域下的某些(个)插件。和全局的 traverse 用法一样。<br>- scope.getBinding(name)获取某个变量的 binding，可以理解为其生命周期。包含引用，修改之类的信息<br>属性：<br>- scope.block 可以用来获取标识符的作用域，返回 <code>Node</code> 对象，使用方法分为两种情况：<code>变量</code> 和 <code>函数</code>,变量获取当前作用域，函数获取函数本身作用域。</h2><h3 id="3-2-1-实例代码"><a href="#3-2-1-实例代码" class="headerlink" title="3.2.1 实例代码"></a>3.2.1 实例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;mankvis&#x27;</span>,</span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">    a = <span class="number">400</span>;</span><br><span class="line">    b = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">let</span> e = <span class="number">700</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">600</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">demo</span>();</span><br><span class="line">    <span class="keyword">return</span> a + a + b + <span class="number">1000</span> + obj.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">add</span>(<span class="number">100</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-2-scope-block"><a href="#3-2-2-scope-block" class="headerlink" title="3.2.2 scope.block"></a>3.2.2 scope.block</h3><p>变量获取 block 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ast = parser.<span class="title function_">parse</span>(jsCode);</span><br><span class="line"></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">name</span> === <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generator</span>(path.<span class="property">scope</span>.<span class="property">block</span>).<span class="property">code</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function (a) &#123;</span></span><br><span class="line"><span class="comment">  a = 400;</span></span><br><span class="line"><span class="comment">  b = 300;</span></span><br><span class="line"><span class="comment">  let e = 700;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  function demo() &#123;</span></span><br><span class="line"><span class="comment">    let d = 600;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  demo();</span></span><br><span class="line"><span class="comment">  return a + a + b + 1000 + obj.name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数获取 block 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generator</span>(path.<span class="property">scope</span>.<span class="property">block</span>).<span class="property">code</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function demo() &#123;</span></span><br><span class="line"><span class="comment">  let d = 600;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-3-scope-dump"><a href="#3-2-3-scope-dump" class="headerlink" title="3.2.3 scope.dump"></a>3.2.3 scope.dump</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n\n这里是函数&#x27;</span>, path.<span class="property">node</span>.<span class="property">id</span>.<span class="property">name</span> + <span class="string">&#x27;()&#x27;</span>);</span><br><span class="line">    path.<span class="property">scope</span>.<span class="title function_">dump</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是函数 demo()</span></span><br><span class="line"><span class="comment">------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># FunctionDeclaration</span></span><br><span class="line"><span class="comment"> - d &#123; constant: true, references: 0, violations: 0, kind: &#x27;let&#x27; &#125;</span></span><br><span class="line"><span class="comment"># FunctionExpression</span></span><br><span class="line"><span class="comment"> - a &#123; constant: false, references: 2, violations: 1, kind: &#x27;param&#x27; &#125;</span></span><br><span class="line"><span class="comment"> - e &#123; constant: true, references: 0, violations: 0, kind: &#x27;let&#x27; &#125;</span></span><br><span class="line"><span class="comment"> - demo &#123; constant: true, references: 1, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span></span><br><span class="line"><span class="comment"># Program</span></span><br><span class="line"><span class="comment"> - a &#123; constant: true, references: 0, violations: 0, kind: &#x27;const&#x27; &#125;</span></span><br><span class="line"><span class="comment"> - b &#123; constant: false, references: 1, violations: 1, kind: &#x27;let&#x27; &#125;</span></span><br><span class="line"><span class="comment"> - obj &#123; constant: true, references: 2, violations: 0, kind: &#x27;let&#x27; &#125;</span></span><br><span class="line"><span class="comment">------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>‘#’开头的是每一个作用域 ，上面有三个作用域，分别是 FunctionDeclaration、FunctionExpression 和 Program。</li><li>‘-‘开头的是每一个绑定（binding），每一个 binding 都会包含几个关键信息，分别是：constant、references、violations、kind。<ul><li>constant 表示是否为常量，为布尔值</li><li>references 表示被引用的次数</li><li>violations 表示被重新定义的次数</li><li>kind 表示声明类型，param 参数、hoisted 提升、var 变量、local 内部。</li></ul></li></ul><h3 id="3-2-4-scope-getBinding"><a href="#3-2-4-scope-getBinding" class="headerlink" title="3.2.4 scope.getBinding"></a>3.2.4 scope.getBinding</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">let</span> bindingA = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bindingA);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Binding &#123;</span></span><br><span class="line"><span class="comment">  identifier: Node &#123;type: &#x27;Identifier&#x27;, ..., name: &#x27;a&#x27;&#125;,</span></span><br><span class="line"><span class="comment">  scope: Scope &#123;</span></span><br><span class="line"><span class="comment">    ...,</span></span><br><span class="line"><span class="comment">    block: Node &#123;type: &#x27;FunctionExpression&#x27;, ...&#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">  path: NodePath &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  kind: &#x27;param&#x27;,</span></span><br><span class="line"><span class="comment">  constantViolations: [...],</span></span><br><span class="line"><span class="comment">  constant: false,</span></span><br><span class="line"><span class="comment">  referencePaths: [...],</span></span><br><span class="line"><span class="comment">  referenced: true,</span></span><br><span class="line"><span class="comment">  references: 2</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>getBinding 中传入的值必须是当前节点能够引用到的标识符名，如果传入一个不存在的 g ，这个标识符并不存在，或者说当前节点引用不到，那么 getBinding 会返回 undefined<br>由于 FunctionDeclaration 的作用域只是 demo 本身， demo 本身的作用域是 add 这个函数，所以是可以直接找到 a 的</p><ul><li>identifier 是 a 标识符的 Node 对象</li><li>path 是 a 表示符的 Path 对象</li><li>kind 表示这是一个参数，但是并不代表就是当前 demo 的参数。实际上原始代码中，a 是 add 的参数（当函数中局部变量与全局变量重名时，使用的是局部变量）</li><li>referencePaths 假设标识符被引用，referencePaths 中会存放所有引用该标识符的节点的 Path 对象</li><li>constantViolations 假如标识符被修改，那么 constantViolations 中会存放所有修改该标识符的节点的 Path 对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取函数作用域方法：</span></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionExpression</span>(path) &#123;</span><br><span class="line">    <span class="keyword">let</span> bindingA = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> bindingDemo = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bindingA.<span class="property">referenced</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bindingA.<span class="property">references</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generator</span>(bindingA.<span class="property">scope</span>.<span class="property">block</span>).<span class="property">code</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generator</span>(bindingDemo.<span class="property">scope</span>.<span class="property">block</span>).<span class="property">code</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">下面代码输出2次</span></span><br><span class="line"><span class="comment">function (a) &#123;</span></span><br><span class="line"><span class="comment">  a = 400;</span></span><br><span class="line"><span class="comment">  b = 300;</span></span><br><span class="line"><span class="comment">  let e = 700;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  function demo() &#123;</span></span><br><span class="line"><span class="comment">    let d = 600;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  demo();</span></span><br><span class="line"><span class="comment">  return a + a + b + 1000 + obj.name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-5-scope-getOwnBinding"><a href="#3-2-5-scope-getOwnBinding" class="headerlink" title="3.2.5 scope.getOwnBinding"></a>3.2.5 scope.getOwnBinding</h3><p><code>scope.getOwnBinding</code> 该函数用于获取当前节点自己的绑定，也就是不包含父级作用域中定义的标识符的绑定，但是该函数会得到子函数中定义的标识符的绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TestOwnBinding</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  path.<span class="title function_">traverse</span>(&#123;</span><br><span class="line">    <span class="title class_">Identifier</span>(p) &#123;</span><br><span class="line">      <span class="keyword">let</span> name = p.<span class="property">node</span>.<span class="property">name</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(name, !!p.<span class="property">scope</span>.<span class="title function_">getOwnBinding</span>(name));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionExpression</span>(path) &#123;</span><br><span class="line">    <span class="title class_">TestOwnBinding</span>(path);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">b false</span></span><br><span class="line"><span class="comment">e true</span></span><br><span class="line"><span class="comment">demo false</span></span><br><span class="line"><span class="comment">d true</span></span><br><span class="line"><span class="comment">demo true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">b false</span></span><br><span class="line"><span class="comment">obj false</span></span><br><span class="line"><span class="comment">name false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TestOwnBinding</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  path.<span class="title function_">traverse</span>(&#123;</span><br><span class="line">    <span class="title class_">Identifier</span>(p) &#123;</span><br><span class="line">      <span class="keyword">let</span> name = p.<span class="property">node</span>.<span class="property">name</span>;</span><br><span class="line">      <span class="keyword">let</span> binding = p.<span class="property">scope</span>.<span class="title function_">getBinding</span>(name);</span><br><span class="line">      binding &amp;&amp; <span class="variable language_">console</span>.<span class="title function_">log</span>(name, <span class="title function_">generator</span>(binding.<span class="property">scope</span>.<span class="property">block</span>).<span class="property">code</span> === path.<span class="title function_">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionExpression</span>(path) &#123;</span><br><span class="line">    <span class="title class_">TestOwnBinding</span>(path);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">b false</span></span><br><span class="line"><span class="comment">e true</span></span><br><span class="line"><span class="comment">demo true</span></span><br><span class="line"><span class="comment">d false</span></span><br><span class="line"><span class="comment">demo true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">b false</span></span><br><span class="line"><span class="comment">obj false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-6-scope-traverse"><a href="#3-2-6-scope-traverse" class="headerlink" title="3.2.6 scope.traverse"></a>3.2.6 scope.traverse</h3><p><code>scope.traverse</code> 方法可以用来遍历作用域中的节点。可以使用 <code>Path</code> 对象中的 <code>scope</code>，也可以使用 <code>Binding</code> 中的 <code>scope</code>，笔者推荐使用后者，下面来看下例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">let</span> binding = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    binding.<span class="property">scope</span>.<span class="title function_">traverse</span>(binding.<span class="property">scope</span>.<span class="property">block</span>, &#123;</span><br><span class="line">      <span class="title class_">AssignmentExpression</span>(p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="property">node</span>.<span class="property">left</span>.<span class="property">name</span> === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">          p.<span class="property">node</span>.<span class="property">right</span> = types.<span class="title function_">numericLiteral</span>(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">const a = 1000;</span></span><br><span class="line"><span class="comment">let b = 2000;</span></span><br><span class="line"><span class="comment">let obj = &#123;</span></span><br><span class="line"><span class="comment">  name: &#x27;mankvis&#x27;,</span></span><br><span class="line"><span class="comment">  add: function (a) &#123;</span></span><br><span class="line"><span class="comment">    a = 500;</span></span><br><span class="line"><span class="comment">    b = 300;</span></span><br><span class="line"><span class="comment">    let e = 700;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    function demo() &#123;</span></span><br><span class="line"><span class="comment">      let d = 600;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    demo();</span></span><br><span class="line"><span class="comment">    return a + a + b + 1000 + obj.name;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">obj.add(100);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-7-scope-rename"><a href="#3-2-7-scope-rename" class="headerlink" title="3.2.7 scope.rename"></a>3.2.7 scope.rename</h3><p>可以使用 <code>scope.rename</code> 将标识符进行重命名，这个方法会同时修改所有引用该标识符的地方，例如将 <code>add</code> 函数中的 <code>b</code> 变量重命名为 <code>x</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionExpression</span>(path) &#123;</span><br><span class="line">    <span class="keyword">let</span> binding = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    binding.<span class="property">scope</span>.<span class="title function_">rename</span>(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">const a = 1000;</span></span><br><span class="line"><span class="comment">let x = 2000;</span></span><br><span class="line"><span class="comment">let obj = &#123;</span></span><br><span class="line"><span class="comment">  name: &#x27;mankvis&#x27;,</span></span><br><span class="line"><span class="comment">  add: function (a) &#123;</span></span><br><span class="line"><span class="comment">    a = 400;</span></span><br><span class="line"><span class="comment">    x = 300;</span></span><br><span class="line"><span class="comment">    let e = 700;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    function demo() &#123;</span></span><br><span class="line"><span class="comment">      let d = 600;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    demo();</span></span><br><span class="line"><span class="comment">    return a + a + x + 1000 + obj.name;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">obj.add(100);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述方法很方便的就把 <code>b</code> 改为了 <code>x</code>，但是如果随便指定一个变量名，可能会与现有标识符发生命名冲突，这时可以使用 <code>scope.generateUidIdentifier</code> 来生成一个标识符，生成的标识符不会与任何本地的标识符相冲突，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line"> <span class="title class_">FunctionExpression</span>(path) &#123;</span><br><span class="line">   path.<span class="property">scope</span>.<span class="title function_">generateUidIdentifier</span>(<span class="string">&#x27;uid&#x27;</span>);</span><br><span class="line">   <span class="comment">// Node &#123;type: &quot;Identifier&quot;, name: &quot;_uid&quot;&#125;</span></span><br><span class="line">   path.<span class="property">scope</span>.<span class="title function_">generateUidIdentifier</span>(<span class="string">&#x27;_uid2&#x27;</span>);</span><br><span class="line">   <span class="comment">// Node &#123;type: &quot;Identifier&quot;, name: &quot;_uid2&quot;&#125;</span></span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-8-scope-hasBinding"><a href="#3-2-8-scope-hasBinding" class="headerlink" title="3.2.8 scope.hasBinding"></a>3.2.8 scope.hasBinding</h3><p>该方法查询某标识符是否有绑定，返回 <code>true</code> 或者 <code>false</code>。可以用 <code>scope.getBinding(&quot;a&quot;)</code> 代替，<code>scope.getBinding(&quot;a&quot;)</code> 返回 <code>undefined</code>，等同于 <code>scope.hasBinding(&quot;a&quot;)</code> 返回 <code>false</code>。</p><h3 id="3-2-9-scope-hasOwnBinding"><a href="#3-2-9-scope-hasOwnBinding" class="headerlink" title="3.2.9 scope.hasOwnBinding"></a>3.2.9 scope.hasOwnBinding</h3><p>该方法查询当前节点中是否有自己的绑定，返回布尔值，例如，对于 <code>demo</code> 函数，<code>OwnBinding</code> 只有一个 <code>d</code>，函数名 <code>demo</code> 虽然也是标识符，但不属于 <code>demo</code> 函数的 <code>OwnBinding</code> 范畴，是属于它的父级作用域中的，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="property">scope</span>.<span class="property">parent</span>.<span class="title function_">hasOwnBinding</span>(<span class="string">&#x27;demo&#x27;</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-10-scope-getAllBindings"><a href="#3-2-10-scope-getAllBindings" class="headerlink" title="3.2.10 scope.getAllBindings"></a>3.2.10 scope.getAllBindings</h3><p>该方法获取当前节点的所有绑定，会返回一个对象。该对象以标识符名为属性名，对应的 <code>Binding</code> 为属性值，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="property">scope</span>.<span class="title function_">getAllBindings</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Object: null prototype] &#123;</span></span><br><span class="line"><span class="comment">  d: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  a: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  demo: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  e: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  b: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  obj: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遍历每一个 <code>Binding</code>，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">BlockStatement</span>(path) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n此块节点源码: \n&#x27;</span>, path.<span class="title function_">toString</span>());</span><br><span class="line">    <span class="keyword">let</span> bindings = path.<span class="property">scope</span>.<span class="property">bindings</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;作用域内被绑定数量:&#x27;</span>, <span class="title class_">Object</span>.<span class="title function_">keys</span>(bindings).<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bindingsKey <span class="keyword">in</span> bindings) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;名字&#x27;</span>, bindingsKey);</span><br><span class="line">      <span class="keyword">let</span> binding_ = bindings[bindingsKey];</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;类型:&#x27;</span>, binding_.<span class="property">kind</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定义:&#x27;</span>, binding_.<span class="property">identifier</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是否常量:&#x27;</span>, binding_.<span class="property">constant</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被修改信息记录:&#x27;</span>, binding_.<span class="property">constantViolations</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是否被引用:&#x27;</span>, binding_.<span class="property">referenced</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被引用次数:&#x27;</span>, binding_.<span class="property">references</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被引用信息NodePath记录&#x27;</span>, binding_.<span class="property">referencePaths</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-------------------------------------&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-11-scope-hasReference"><a href="#3-2-11-scope-hasReference" class="headerlink" title="3.2.11 scope .hasReference"></a>3.2.11 scope .hasReference</h3><p>scope.hasReference(“a”) 表示查询当前节点中是否有 a 标识符的引用，返回布尔值。</p><h3 id="3-2-12-scope-getBindingIdentifier"><a href="#3-2-12-scope-getBindingIdentifier" class="headerlink" title="3.2.12 scope .getBindingIdentifier"></a>3.2.12 scope .getBindingIdentifier</h3><p>scope.getBindingIdentifier(“a”) 表示获取当前节点中绑定的 a 的标识符，返回 Identifier 的 Node 对象。同样，这个方法也有 Own 版本，为 scope.getOwnBindingIdentifier(“a”)。</p><h2 id="3-3-node"><a href="#3-3-node" class="headerlink" title="3.3 node"></a>3.3 node</h2><p>属性：</p><ul><li>path.node.type获取当前节点的类型。</li><li>path.node.declarations对于 VariableDeclaration 节点, 获取变量声明列表。</li><li>path.node.init.value获取某个节点的值。</li><li>delete path.node.init;删除节点，使用系统的 delete 方法。</li></ul><h2 id="3-4-types-类型"><a href="#3-4-types-类型" class="headerlink" title="3.4 types 类型"></a>3.4 types 类型</h2><h2 id="3-5-节点类型对照"><a href="#3-5-节点类型对照" class="headerlink" title="3.5 节点类型对照"></a>3.5 节点类型对照</h2><ul><li>Program程序主体整段代码的主体</li><li>VariableDeclaration变量声明声明一个变量，例如 var let const</li><li>FunctionDeclaration函数声明声明一个函数，例如 function</li><li>ExpressionStatement表达式语句通常是调用一个函数，例如 console.log()</li><li>BlockStatement块语句包裹在 {} 块内的代码，例如 if (condition){var a &#x3D; 1;}</li><li>BreakStatement中断语句通常指 break</li><li>ContinueStatement持续语句通常指 continue</li><li>ReturnStatement返回语句通常指 return</li><li>SwitchStatementSwitch 语句通常指 Switch Case 语句中的 Switch</li><li>IfStatementIf 控制流语句控制流语句，通常指 if(condition){}else{}</li><li>Identifier标识符标识，例如声明变量时 var identi &#x3D; 5 中的 identi</li><li>CallExpression调用表达式通常指调用一个函数，例如 console.log()</li><li>BinaryExpression二进制表达式通常指运算，例如 1+2</li><li>MemberExpression成员表达式通常指调用对象的成员，例如 console 对象的 log 成员</li><li>ArrayExpression数组表达式通常指一个数组，例如 [1, 3, 5]</li><li>NewExpressionNew 表达式通常指使用 New 关键词</li><li>AssignmentExpression赋值表达式通常指将函数的返回值赋值给变量</li><li>UpdateExpression更新表达式通常指更新成员值，例如 i++</li><li>Literal字面量字面量</li><li>BooleanLiteral布尔型字面量布尔值，例如 true false</li><li>NumericLiteral数字型字面量数字，例如 100</li><li>StringLiteral字符型字面量字符串，例如 vansenb</li><li>SwitchCaseCase 语句通常指 Switch 语句中的 Case</li><li>SequenceExpression 一个序列表达式，也就是由逗号分割的表达式序列</li><li>FunctionExpression 函数赋值语句</li></ul><h1 id="4-常用技巧"><a href="#4-常用技巧" class="headerlink" title="4 常用技巧"></a>4 常用技巧</h1><h2 id="4-1-基础使用框架"><a href="#4-1-基础使用框架" class="headerlink" title="4.1 基础使用框架"></a>4.1 基础使用框架</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decrypt.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).<span class="property">default</span>;</span><br><span class="line"><span class="keyword">const</span> types = <span class="built_in">require</span>(<span class="string">&#x27;@babel/types&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> generator = <span class="built_in">require</span>(<span class="string">&#x27;@babel/generator&#x27;</span>).<span class="property">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序启动时间</span></span><br><span class="line"><span class="keyword">var</span> time_start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line">process.<span class="property">argv</span>.<span class="property">length</span> &gt; <span class="number">2</span> ? encode_file = process.<span class="property">argv</span>[<span class="number">2</span>] : encode_file = <span class="string">&#x27;encode.js&#x27;</span>;</span><br><span class="line">process.<span class="property">argv</span>.<span class="property">length</span> &gt; <span class="number">3</span> ? decode_file = process.<span class="property">argv</span>[<span class="number">3</span>] : decode_file = <span class="string">&#x27;decode.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jscode = fs.<span class="title function_">readFileSync</span>(encode_file, &#123;<span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 转换为 ast 树</span></span><br><span class="line"><span class="keyword">let</span> ast = parser.<span class="title function_">parse</span>(jscode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visitor =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此处编写 babel 处理代码、插件代码</span></span><br><span class="line">        <span class="title class_">ASTNodeTypeHere</span>(path, state) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如</span></span><br><span class="line">        <span class="comment">// Identifier(path, state) &#123;&#125;</span></span><br><span class="line">        <span class="comment">// Identifier(path) &#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用插件，处理待处理 js ast 树</span></span><br><span class="line"><span class="title function_">traverse</span>(ast, visitor);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;AST traverse completed.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成处理后的 js</span></span><br><span class="line"><span class="keyword">let</span> &#123;code&#125; = <span class="title function_">generator</span>(ast);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;AST generator completed.&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">writeFile</span>(decode_file, code, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(util.<span class="title function_">format</span>(<span class="string">&#x27;The javascript code in [%s] has been processed.&#x27;</span>, encode_file))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(util.<span class="title function_">format</span>(<span class="string">&#x27;The processing result has been saved to [%s].&#x27;</span>, decode_file))</span><br><span class="line"><span class="comment">// 程序结束时间</span></span><br><span class="line"><span class="keyword">var</span> time_end = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(util.<span class="title function_">format</span>(<span class="string">&#x27;The program runs to completion, time-consuming: %s s&#x27;</span>, (time_end - time_start) / <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><h2 id="4-2-打印原来的节点的源码-toString"><a href="#4-2-打印原来的节点的源码-toString" class="headerlink" title="4.2 打印原来的节点的源码 toString()"></a>4.2 打印原来的节点的源码 toString()</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = <span class="string">&#x27;var a = 1&#x27;</span></span><br><span class="line"><span class="keyword">const</span> visitor = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">VariableDeclarator</span>(path)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">toString</span>()); <span class="comment">// a = 1</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generator</span>(path.<span class="property">node</span>).<span class="property">code</span>) <span class="comment">// a= 1</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-构造节点-t-valueToNode"><a href="#4-3-构造节点-t-valueToNode" class="headerlink" title="4.3 构造节点 t.valueToNode()"></a>4.3 构造节点 t.valueToNode()</h2><p>(可以代替t.NumericLiteral(234567)，t.StringLiteral(‘1234’) 注意：使用这两种过传参类型必须和声明类型一样，如果使用 valueNode 的话就是传入参数的默认类型)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="title class_">VariableDeclarator</span>(path)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="title function_">valueToNode</span>(<span class="string">&#x27;123&#x27;</span>));  <span class="comment">// &#123; type: &#x27;StringLiteral&#x27;, value: &#x27;123&#x27; &#125;</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="title function_">valueToNode</span>(<span class="number">123</span>));  <span class="comment">//  &#123; type: &#x27;NumericLiteral&#x27;, value: 123 &#125;</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="title function_">valueToNode</span>(<span class="literal">null</span>))  <span class="comment">//  &#123; type: &#x27;NullLiteral&#x27; &#125;</span></span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-替换节点-replaceWith"><a href="#4-4-替换节点-replaceWith" class="headerlink" title="4.4 替换节点 replaceWith"></a>4.4 替换节点 replaceWith</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;VariableDeclarator&#x27;</span>(path)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">toString</span>());  <span class="comment">//a = 1</span></span><br><span class="line">        path.<span class="title function_">replaceWith</span>(t.<span class="title function_">valueToNode</span>(<span class="number">1</span>)) <span class="comment">//var 1;</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-删除节点-remove"><a href="#4-5-删除节点-remove" class="headerlink" title="4.5 删除节点 remove()"></a>4.5 删除节点 remove()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;VariableDeclarator&#x27;</span>(path)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">toString</span>())  <span class="comment">// a = 1 + 2;b = 2</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">id</span>.<span class="property">name</span> === <span class="string">&#x27;b&#x27;</span>)&#123;</span><br><span class="line">        path.<span class="title function_">remove</span>()&#125;; </span><br><span class="line">&#125;&#125; <span class="comment">// 还原为var a = 1 + 2;</span></span><br></pre></td></tr></table></figure><h2 id="4-6-判断节点类型-isVariableDeclarator"><a href="#4-6-判断节点类型-isVariableDeclarator" class="headerlink" title="4.6 判断节点类型 isVariableDeclarator"></a>4.6 判断节点类型 isVariableDeclarator</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;VariableDeclarator&#x27;</span>(path)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">toString</span>()) <span class="comment">//a = 1 + 2</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="property">type</span>); <span class="comment">// VariableDeclarator</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="title function_">isVariableDeclarator</span>(path.<span class="property">node</span>))  <span class="comment">//true</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">isVariableDeclarator</span>()) <span class="comment">// true</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-节点设置值-set-key-node"><a href="#4-7-节点设置值-set-key-node" class="headerlink" title="4.7 节点设置值 set(key,node)"></a>4.7 节点设置值 set(key,node)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="comment">// 将var a修改为 var a</span></span><br><span class="line">    <span class="string">&#x27;VariableDeclarator&#x27;</span>(path)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">toString</span>())  <span class="comment">//a</span></span><br><span class="line">        <span class="keyword">const</span> &#123;init&#125; = path.<span class="property">node</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(init === path.<span class="property">node</span>.<span class="property">init</span>) <span class="comment">//true</span></span><br><span class="line">        init || path.<span class="title function_">set</span>(<span class="string">&#x27;init&#x27;</span>, t.<span class="title class_">Identifier</span>(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">&#125;&#125; <span class="comment">//输出为var a = 1;</span></span><br></pre></td></tr></table></figure><h2 id="4-8-插入节点"><a href="#4-8-插入节点" class="headerlink" title="4.8 插入节点"></a>4.8 插入节点</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;Identifier&#x27;</span> (path) &#123;</span><br><span class="line">        path.<span class="title function_">insertBefore</span>(t.<span class="title function_">valueToNode</span>(<span class="string">&#x27;22&#x27;</span>)); <span class="comment">//节点前插入</span></span><br><span class="line">        path.<span class="title function_">insertAfter</span>(t.<span class="title function_">valueToNode</span>(<span class="string">&#x27;22&#x27;</span>));<span class="comment">//节点后插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-高级技巧"><a href="#5-高级技巧" class="headerlink" title="5 高级技巧"></a>5 高级技巧</h1><h2 id="5-1-执行-path"><a href="#5-1-执行-path" class="headerlink" title="5.1 执行 path"></a>5.1 执行 path</h2><p>使用 <code>path.evaluate()</code> ，返回的 <code>confident</code> 为 <code>true</code> 则表明成功执行，<code>value</code> 为返回值<br>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; confident, value &#125; = path.evaluate();</span><br></pre></td></tr></table></figure><h2 id="5-2-多个节点组合查询"><a href="#5-2-多个节点组合查询" class="headerlink" title="5.2 多个节点组合查询"></a>5.2 多个节点组合查询</h2><p>使用 <code>|</code> 把需要访问的节点组合起来即可，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">  <span class="string">&#x27;VariableDeclarator|FunctionDeclaration&#x27;</span>(path) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">traverse</span>(ast, visitor);</span><br></pre></td></tr></table></figure><h2 id="5-3-删除无用的空语句"><a href="#5-3-删除无用的空语句" class="headerlink" title="5.3 删除无用的空语句"></a>5.3 删除无用的空语句</h2><p>删除空语句 <code>;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;EmptyStatement&#x27;</span>(path) &#123;</span><br><span class="line">    path.<span class="title function_">remove</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-删除无用节点"><a href="#5-4-删除无用节点" class="headerlink" title="5.4 删除无用节点"></a>5.4 删除无用节点</h2><p>&#96;path.remove()</p><h2 id="5-5-查看作用域-scope"><a href="#5-5-查看作用域-scope" class="headerlink" title="5.5 查看作用域 scope"></a>5.5 查看作用域 scope</h2><p><code>path.scope.dump()</code> 即可查看自底向上的作用域</p><h2 id="5-6-同一节点使用多个函数"><a href="#5-6-同一节点使用多个函数" class="headerlink" title="5.6 同一节点使用多个函数"></a>5.6 同一节点使用多个函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log_a</span>(<span class="params">path</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is [a] function -- &#x27;</span> + path.<span class="property">node</span>.<span class="property">init</span>.<span class="property">value</span>); &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log_b</span>(<span class="params">path</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is [b] function -- &#x27;</span> + path.<span class="property">node</span>.<span class="property">init</span>.<span class="property">value</span>); &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log_c</span>(<span class="params">path</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is [c] function -- &#x27;</span> + path.<span class="property">node</span>.<span class="property">init</span>.<span class="property">value</span>); &#125;</span><br><span class="line"><span class="keyword">const</span> visitor =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;VariableDeclarator&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;enter&#x27;</span>: [log_a, log_c, log_b]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">traverse</span>(ast, visitor);</span><br></pre></td></tr></table></figure><p><strong>请注意！</strong><br><strong>enter 需为数组！函数执行顺序为列表中函数顺序！</strong></p><h2 id="5-7-删除未使用的-function、var、let、const"><a href="#5-7-删除未使用的-function、var、let、const" class="headerlink" title="5.7 删除未使用的 function、var、let、const"></a>5.7 删除未使用的 function、var、let、const</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="title class_">VariableDeclarator</span>(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = path.<span class="property">node</span>;</span><br><span class="line">    <span class="keyword">let</span> binding = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(id.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binding.<span class="property">referenced</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="title function_">remove</span>();</span><br><span class="line">    path.<span class="property">scope</span>.<span class="title function_">crawl</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = path.<span class="property">node</span>;</span><br><span class="line">    <span class="comment">// 防止函数中存在变量与函数名相同，且该变量在函数中使用，导致未去除未使用函数</span></span><br><span class="line">    <span class="keyword">let</span> binding = path.<span class="property">scope</span>.<span class="property">parent</span>.<span class="title function_">getBinding</span>(id.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binding.<span class="property">referenced</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="title function_">remove</span>();</span><br><span class="line">    <span class="comment">// 手动更新 scope ，防止影响下个插件使用</span></span><br><span class="line">    path.<span class="property">scope</span>.<span class="title function_">crawl</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-8-a-‘bb’-转换为-a-bb"><a href="#5-8-a-‘bb’-转换为-a-bb" class="headerlink" title="5.8 a[‘bb’] 转换为 a.bb"></a>5.8 a[‘bb’] 转换为 a.bb</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">MemberExpression</span>(path) &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; computed &#125; = path.<span class="property">node</span>;</span><br><span class="line">        <span class="comment">// 获取 path property 子路径</span></span><br><span class="line">        <span class="keyword">let</span> property = path.<span class="title function_">get</span>(<span class="string">&#x27;property&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (computed &amp;&amp; types.<span class="title function_">isStringLiteral</span>(property)) &#123;</span><br><span class="line">            property.<span class="title function_">replaceWith</span>(types.<span class="title function_">identifier</span>(property.<span class="property">node</span>.<span class="property">value</span>));</span><br><span class="line">            path.<span class="property">node</span>.<span class="property">computed</span>=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-9-简单控制流"><a href="#5-9-简单控制流" class="headerlink" title="5.9 简单控制流"></a>5.9 简单控制流</h2><p>待处理代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="string">&quot;3|0|1|2|4&quot;</span>.<span class="title function_">split</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (arr[cnt++]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is case-block 0&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is case-block 1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is case-block 2&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is case-block 3&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is case-block 4&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单还原后的结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;This is case-block 3&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;This is case-block 0&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;This is case-block 1&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;This is case-block 2&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;This is case-block 4&quot;</span>);</span><br></pre></td></tr></table></figure><p>插件为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&#x27;WhileStatement&#x27;</span>(path)&#123;</span><br><span class="line">      <span class="comment">// console.log(path.node)</span></span><br><span class="line">      <span class="keyword">const</span> &#123;test, body&#125; = path.<span class="property">node</span>;</span><br><span class="line">      <span class="keyword">if</span> (!t.<span class="title function_">isBooleanLiteral</span>(test) || test.<span class="property">value</span> !== <span class="literal">true</span>)&#123;<span class="keyword">return</span>&#125;;</span><br><span class="line">      <span class="keyword">if</span> (body.<span class="property">body</span>.<span class="property">length</span> === <span class="number">0</span> || !t.<span class="title function_">isSwitchStatement</span>(body.<span class="property">body</span>[<span class="number">0</span>])) &#123;<span class="keyword">return</span>&#125;;</span><br><span class="line">      <span class="keyword">let</span> switch_state = body.<span class="property">body</span>[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">let</span>&#123;discriminant, cases&#125; = switch_state;</span><br><span class="line">      <span class="keyword">if</span> (!t.<span class="title function_">isMemberExpression</span>(discriminant) || !t.<span class="title function_">isUpdateExpression</span>(discriminant.<span class="property">property</span>))&#123;<span class="keyword">return</span>&#125;;</span><br><span class="line">      <span class="comment">//获取while循环变量名称</span></span><br><span class="line">      <span class="keyword">let</span> arr_name = discriminant.<span class="property">object</span>.<span class="property">name</span>;</span><br><span class="line">      <span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、获取while所有以上兄弟节点，获取控制流属组</span></span><br><span class="line">      <span class="keyword">let</span> all_pre_siblings = path.<span class="title function_">getAllPrevSiblings</span>();</span><br><span class="line">      <span class="keyword">if</span> (all_pre_siblings.<span class="property">length</span> !== <span class="number">2</span>)&#123;<span class="keyword">return</span>&#125;;</span><br><span class="line"><span class="comment">//2、根据循环变量名称判断控制流属组位置</span></span><br><span class="line">      all_pre_siblings.<span class="title function_">forEach</span>(<span class="function"><span class="params">pre_pth</span> =&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">const</span> &#123;declarations&#125; = pre_pth.<span class="property">node</span>;</span><br><span class="line">          <span class="keyword">let</span> &#123;id, init&#125; = declarations[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">if</span> (arr_name == id.<span class="property">name</span>)&#123;</span><br><span class="line">              arr = init.<span class="property">callee</span>.<span class="property">object</span>.<span class="property">value</span>.<span class="title function_">split</span>(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          pre_pth.<span class="title function_">remove</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">let</span> ret_body = [];</span><br><span class="line">      arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">index</span> =&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> case_body = cases[index].<span class="property">consequent</span>;</span><br><span class="line">          <span class="comment">//如果case里面含有continue语句，将属组弹出</span></span><br><span class="line">          <span class="keyword">if</span> (t.<span class="title function_">isContinueStatement</span>(case_body[case_body.<span class="property">length</span> -<span class="number">1</span>]))</span><br><span class="line">              &#123;case_body.<span class="title function_">pop</span>()&#125;</span><br><span class="line">          ret_body = ret_body.<span class="title function_">concat</span>(case_body)</span><br><span class="line">      &#125;)</span><br><span class="line">      path.<span class="title function_">replaceInline</span>(ret_body)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="5-10-自执行函数替换（固定函数参数）"><a href="#5-10-自执行函数替换（固定函数参数）" class="headerlink" title="5.10 自执行函数替换（固定函数参数）"></a>5.10 自执行函数替换（固定函数参数）</h2><p>待处理代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span>(<span class="params">a,b</span>) &#123;c = a | b;&#125;(<span class="number">111</span>,<span class="number">222</span>);</span><br></pre></td></tr></table></figure><p>简单还原后的结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span>(<span class="params"></span>) &#123;c = <span class="number">111</span> | <span class="number">222</span>&#125;();</span><br></pre></td></tr></table></figure><p>插件为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CallExpression(path) &#123;</span><br><span class="line">        <span class="keyword">let</span> callee = path.<span class="keyword">get</span>(<span class="string">&#x27;callee&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> arguments = path.<span class="keyword">get</span>(<span class="string">&#x27;arguments&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!callee.isFunctionExpression() || arguments.length === <span class="number">0</span>) &#123; <span class="comment">//这里实参的长度判断可以写死。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对着网站解析，获取形参</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">params</span> = callee.<span class="keyword">get</span>(<span class="string">&#x27;params&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> scope = callee.scope;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123; <span class="comment">//遍历实参，因为形参可能比实参长。</span></span><br><span class="line">            <span class="keyword">let</span> arg = <span class="keyword">params</span>[i];</span><br><span class="line">            <span class="keyword">let</span> &#123;</span><br><span class="line">                name</span><br><span class="line">            &#125; = arg.node;</span><br><span class="line">            <span class="keyword">const</span> binding = scope.getBinding(name); <span class="comment">// 在当前作用域中，找到参数的引用</span></span><br><span class="line">            console.log(binding)</span><br><span class="line">            <span class="keyword">if</span> (!binding || binding.constantViolations.length &gt; <span class="number">0</span>) &#123; <span class="comment">//形参有被改变，不能被还原</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 表示在当前作用域中的引用，因为现在的作用域是整个函数，所有如果&#x27;!function(a,b) &#123;c = a | b;a=1&#125;(111,222);&#x27;或者&#x27;!function(a,b) &#123;a=1;c = a | b&#125;(111,222);&#x27;是无法修改a的值的</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (refer_path of binding.referencePaths) &#123; <span class="comment">//因为是字面量，所以直接替换，但是遇到Array类型的需要另外处理</span></span><br><span class="line">                <span class="comment">//也无非获取父节点，然后判断索引</span></span><br><span class="line">                refer_path.replaceWith(arguments[i]);</span><br><span class="line">                <span class="comment">//上面的参数可以是path，也可以是node。但是我遇到过path报错，node可以的情况。</span></span><br><span class="line">            &#125;</span><br><span class="line">            arg.<span class="keyword">remove</span>();</span><br><span class="line">            arguments[i].<span class="keyword">remove</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-学习网站&quot;&gt;&lt;a href=&quot;#1-学习网站&quot; class=&quot;headerlink&quot; title=&quot;1 学习网站&quot;&gt;&lt;/a&gt;1 学习网站&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blogz.gitee.io/ast/&quot;&gt;AST explor</summary>
      
    
    
    
    <category term="JS逆向" scheme="http://suzi007.github.io/categories/JS%E9%80%86%E5%90%91/"/>
    
    <category term="逆向工具" scheme="http://suzi007.github.io/categories/JS%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="JS逆向" scheme="http://suzi007.github.io/tags/JS%E9%80%86%E5%90%91/"/>
    
    <category term="AST还原" scheme="http://suzi007.github.io/tags/AST%E8%BF%98%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>爬虫常用库</title>
    <link href="http://suzi007.github.io/2024/04/14/%E7%88%AC%E8%99%AB%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    <id>http://suzi007.github.io/2024/04/14/%E7%88%AC%E8%99%AB%E5%B8%B8%E7%94%A8%E5%BA%93/</id>
    <published>2024-04-14T13:43:02.000Z</published>
    <updated>2024-04-14T15:08:27.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-通用库"><a href="#1-通用库" class="headerlink" title="1 通用库"></a>1 通用库</h1><p>1.urllib -网络库(stdlib)。<br>2.requests -网络库。<br>3.grab – 网络库（基于pycurl）。<br>4.pycurl – 网络库（绑定libcurl）。<br>5.urllib3 – Python HTTP库，安全连接池、支持文件post、可用性高。<br>6.httplib2 – 网络库。<br>7.RoboBrowser – 一个简单的、极具Python风格的Python库，无需独立的浏览器即可浏览网页。<br>8.MechanicalSoup -一个与网站自动交互Python库。<br>9.mechanize -有状态、可编程的Web浏览库。<br>10.socket – 底层网络接口(stdlib)。<br>11.Unirest for Python – Unirest是一套可用于多种语言的轻量级的HTTP库。<br>12.hyper – Python的HTTP&#x2F;2客户端。<br>13.PySocks – SocksiPy 更新并积极维护的版本，包括错误修复和一些其他的特征。作为 socket 模块的直接替换。</p><h1 id="2-网络爬虫框架"><a href="#2-网络爬虫框架" class="headerlink" title="2 网络爬虫框架"></a>2 网络爬虫框架</h1><p>grab – 网络爬虫框架（基于 pycurl&#x2F;multicur）。<br>scrapy – 网络爬虫框架（基于 twisted），不支持 Python3。<br>pyspider – 一个强大的爬虫系统。<br>cola – 一个分布式爬虫框架。<br>portia – 基于 Scrapy 的可视化爬虫。<br>restkit – Python 的 HTTP 资源工具包。它可以让你轻松地访问 HTTP 资源，并围绕它建立的对象。<br>demiurge – 基于PyQuery的爬虫微框架。</p><h1 id="3-HTML-XML-解析器"><a href="#3-HTML-XML-解析器" class="headerlink" title="3 HTML&#x2F;XML 解析器"></a>3 HTML&#x2F;XML 解析器</h1><h2 id="3-1-通用"><a href="#3-1-通用" class="headerlink" title="3.1 通用"></a>3.1 通用</h2><p>lxml – C 语言编写高效 HTML&#x2F; XML 处理库。支持 XPath。<br>cssselect – 解析 DOM 树和 CSS 选择器。<br>pyquery – 解析 DOM 树和 jQuery 选择器。<br>BeautifulSoup – 低效 HTML&#x2F; XML 处理库，纯 Python 实现。<br>html5lib – 根据 WHATWG 规范生成 HTML&#x2F; XML 文档的 DOM。该规范被用在现在所有的浏览器上。<br>feedparser – 解析 RSS&#x2F;ATOM feeds。<br>MarkupSafe – 为 XML&#x2F;HTML&#x2F;XHTML 提供了安全转义的字符串。<br>xmltodict – 一个可以让你在处理 XML 时感觉像在处理 JSON 一样的 Python 模块。<br>xhtml2pdf – 将 HTML&#x2F;CSS 转换为 PDF。<br>untangle – 轻松实现将XML文件转换为Python对象。</p><h2 id="3-2-清理"><a href="#3-2-清理" class="headerlink" title="3.2 清理"></a>3.2 清理</h2><p>Bleach – 清理 HTML（需要 html5lib）。<br>sanitize – 为混乱的数据世界带来清明。</p><h1 id="4-文本处理"><a href="#4-文本处理" class="headerlink" title="4 文本处理"></a>4 文本处理</h1><p>difflib – （Python 标准库）帮助进行差异化比较。<br>Levenshtein – 快速计算Levenshtein距离和字符串相似度。<br>fuzzywuzzy – 模糊字符串匹配。<br>esmre – 正则表达式加速器。<br>ftfy – 自动整理 Unicode 文本，减少碎片化。</p><h1 id="5-自然语言处理"><a href="#5-自然语言处理" class="headerlink" title="5 自然语言处理"></a>5 自然语言处理</h1><p>NLTK -编写 Python 程序来处理人类语言数据的最好平台。<br>Pattern – Python 的网络挖掘模块。他有自然语言处理工具，机器学习以及其它。<br>TextBlob – 为深入自然语言处理任务提供了一致的 API。是基于 NLTK 以及 Pattern 的巨人之肩上发展的。<br>jieba – 中文分词工具。<br>SnowNLP – 中文文本处理库。<br>loso – 另一个中文分词库。</p><h1 id="6-浏览器自动化与仿真"><a href="#6-浏览器自动化与仿真" class="headerlink" title="6 浏览器自动化与仿真"></a>6 浏览器自动化与仿真</h1><p>selenium – 自动化真正的浏览器（Chrome 浏览器，火狐浏览器，Opera 浏览器，IE 浏览器）。<br>Ghost.py – 对 PyQt 的 webkit 的封装（需要 PyQT）。<br>Spynner – 对 PyQt 的 webkit 的封装（需要 PyQT）。<br>Splinter – 通用 API 浏览器模拟器（selenium web 驱动，Django 客户端，Zope）。</p><h1 id="7-多重处理"><a href="#7-多重处理" class="headerlink" title="7 多重处理"></a>7 多重处理</h1><p>threading – Python 标准库的线程运行。对于 I&#x2F;O 密集型任务很有效。对于 CPU 绑定的任务没用，因为 python GIL。<br>multiprocessing – 标准的 Python 库运行多进程。<br>celery – 基于分布式消息传递的异步任务队列&#x2F;作业队列。<br>concurrent-futures – concurrent-futures 模块为调用异步执行提供了一个高层次的接口。</p><h1 id="8-异步网络编程"><a href="#8-异步网络编程" class="headerlink" title="8 异步网络编程"></a>8 异步网络编程</h1><p>asyncio – （在 Python 3.4 +版本以上的 Python 标准库）异步 I&#x2F;O，时间循环，协同程序和任务。<br>Twisted – 基于事件驱动的网络引擎框架。<br>Tornado – 一个网络框架和异步网络库。<br>pulsar – Python 事件驱动的并发框架。<br>diesel – Python 的基于绿色事件的 I&#x2F;O 框架。<br>gevent – 一个使用 greenlet 的基于协程的 Python 网络库。<br>eventlet – 有 WSGI 支持的异步框架。<br>Tomorrow – 异步代码的奇妙的修饰语法。</p><h1 id="9-队列"><a href="#9-队列" class="headerlink" title="9 队列"></a>9 队列</h1><p>celery – 基于分布式消息传递的异步任务队列&#x2F;作业队列。<br>huey – 小型多线程任务队列。<br>mrq – Mr. Queue – 使用 redis &amp; Gevent 的 Python 分布式工作任务队列。<br>RQ – 基于 Redis 的轻量级任务队列管理器。<br>simpleq – 一个简单的，可无限扩展，基于 Amazon SQS 的队列。<br>python-gearman – Gearman 的 Python API。</p><h1 id="10-云计算"><a href="#10-云计算" class="headerlink" title="10 云计算"></a>10 云计算</h1><p>picloud – 云端执行 Python 代码。<br>dominoup.com – 云端执行 R，Python 和 matlab 代码</p><h1 id="11-网页内容提取"><a href="#11-网页内容提取" class="headerlink" title="11 网页内容提取"></a>11 网页内容提取</h1><p>HTML 页面的文本和元数据<br>newspaper – 用 Python 进行新闻提取、文章提取和内容策展。<br>html2text – 将 HTML 转为 Markdown 格式文本。<br>python-goose – HTML 内容&#x2F;文章提取器。<br>lassie – 人性化的网页内容检索工具</p><h1 id="12-WebSocket"><a href="#12-WebSocket" class="headerlink" title="12 WebSocket"></a>12 WebSocket</h1><p>Crossbar – 开源的应用消息传递路由器（Python 实现的用于 Autobahn 的 WebSocket 和 WAMP）。<br>AutobahnPython – 提供了 WebSocket 协议和 WAMP 协议的 Python 实现并且开源。<br>WebSocket-for-Python – Python 2和3以及 PyPy 的 WebSocket 客户端和服务器库。</p><h1 id="13-DNS-解析"><a href="#13-DNS-解析" class="headerlink" title="13 DNS 解析"></a>13 DNS 解析</h1><p>dnsyo – 在全球超过1500个的 DNS 服务器上检查你的 DNS。<br>pycares – c-ares 的接口。c-ares 是进行 DNS 请求和异步名称决议的 C 语言库。</p><h1 id="14-计算机视觉"><a href="#14-计算机视觉" class="headerlink" title="14 计算机视觉"></a>14 计算机视觉</h1><p>OpenCV – 开源计算机视觉库。<br>SimpleCV – 用于照相机、图像处理、特征提取、格式转换的简介，可读性强的接口（基于 OpenCV）。<br>mahotas – 快速计算机图像处理算法（完全使用 C++ 实现），完全基于 numpy 的数组作为它的数据类型。</p><h1 id="15-Web-开发"><a href="#15-Web-开发" class="headerlink" title="15 Web 开发"></a>15 Web 开发</h1><h2 id="15-1-Django"><a href="#15-1-Django" class="headerlink" title="15.1 Django"></a>15.1 Django</h2><p>Django 是一个开源的 Web 应用框架，由 Python 写成，支持许多数据库引擎，可以让 Web 开发变得迅速和可扩展，并会不断的版本更新以匹配 Python 最新版本，如果是新手程序员，可以从这个框架入手。</p><h2 id="15-2-Flask"><a href="#15-2-Flask" class="headerlink" title="15.2 Flask"></a>15.2 Flask</h2><p>Flask 是一个轻量级的 Web 应用框架, 使用 Python 编写。基于 WerkzeugWSGI 工具箱和 Jinja2模板引擎。使用 BSD 授权。<br>Flask 也被称为 “microframework” ，因为它使用简单的核心，用 extension 增加其他功能。Flask 没有默认使用的数据库、窗体验证工具。然而，Flask 保留了扩增的弹性，可以用 Flask-extension 加入这些功 能：ORM、窗体验证工具、文件上传、各种开放式身份验证技术。</p><h2 id="15-3-Web2py"><a href="#15-3-Web2py" class="headerlink" title="15.3 Web2py"></a>15.3 Web2py</h2><p>Web2py 是一个用 Python 语言编写的免费的开源 Web 框架，旨在敏捷快速的开发 Web 应用，具有快速、可扩展、安全以及可移植的数据库驱动的应用，遵循 LGPLv3开源协议。</p><p>Web2py 提供一站式的解决方案，整个开发过程都可以在浏览器上进行，提供了 Web 版的在线开发，HTML 模版编写，静态文件的上传，数据库的编写的功能。其它的还有日志功能，以及一个自动化的 admin 接口。</p><h2 id="15-4-Tornado"><a href="#15-4-Tornado" class="headerlink" title="15.4 Tornado"></a>15.4 Tornado</h2><p>ornado 即是一个 Web server（对此本文不作详述），同时又是一个类 web.py 的 micro-framework，作为框架 Tornado 的思想主要来源于 Web.py，大家在 Web.py 的网站首页也可以看到 Tornado 的大佬 Bret Taylor 的这么一段话（他这里说的 FriendFeed 用的框架跟 Tornado 可以看作是一个东西）</p><h2 id="15-5-CherryPy"><a href="#15-5-CherryPy" class="headerlink" title="15.5 CherryPy"></a>15.5 CherryPy</h2><p>CherryPy是一种用于Python的、简单而非常有用的Web框架，其主要作用是以尽可能少的操作将Web服务器与Python代码连接，其功能包括内置的分析功能、灵活的插件系统以及一次运行多个HTTP服务器的功能，可与运行在最新版本的Python、Jython、Android上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-通用库&quot;&gt;&lt;a href=&quot;#1-通用库&quot; class=&quot;headerlink&quot; title=&quot;1 通用库&quot;&gt;&lt;/a&gt;1 通用库&lt;/h1&gt;&lt;p&gt;1.urllib -网络库(stdlib)。&lt;br&gt;2.requests -网络库。&lt;br&gt;3.grab – 网络库</summary>
      
    
    
    
    <category term="爬虫框架" scheme="http://suzi007.github.io/categories/%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="爬虫程序设计" scheme="http://suzi007.github.io/tags/%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="爬虫常用库" scheme="http://suzi007.github.io/tags/%E7%88%AC%E8%99%AB%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
  </entry>
  
</feed>
